{"config":{"lang":["en","es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to WhatsPlay","text":"<p>WhatsPlay is a Python library for automating WhatsApp Web using Playwright. It provides a simple, event-driven interface to interact with chats, send messages, manage groups, and much more.</p> <p>Whether you want to build a bot, automate your daily reports, or scrape chat data, WhatsPlay gives you the tools to do it efficiently.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Event-Driven: Easily handle events like incoming messages, QR scans, or when the client is ready.</li> <li>Modern Async API: Built with <code>asyncio</code> for high performance.</li> <li>Session Management: Saves your session locally so you don't have to scan the QR code every time.</li> <li>Group Management: Create groups, add/remove members, and more.</li> <li>File &amp; Media Support: Send images, documents, and other files with ease.</li> </ul>"},{"location":"#a-quick-example","title":"A Quick Example","text":"<p>Here's a simple script to send a message to a contact:</p> <pre><code>import asyncio\nfrom whatsplay import Client\nfrom whatsplay.auth import LocalProfileAuth\n\nasync def main():\n    auth = LocalProfileAuth(\"./whatsapp_session\")\n    client = Client(auth=auth, headless=True)\n\n    @client.event(\"on_start\")\n    async def on_start():\n        print(\"Client started! Sending message...\")\n\n        # Use a phone number (e.g., \"1234567890\") or a saved contact name\n        # For phone numbers, include the country code without '+' or '00'\n        recipient = \"PHONE_NUMBER_OR_CONTACT_NAME\"\n        message = \"Hello from WhatsPlay! \ud83d\ude80\"\n\n        success = await client.send_message(recipient, message)\n\n        if success:\n            print(f\"Message sent successfully to {recipient}.\")\n        else:\n            print(f\"Failed to send message to {recipient}.\")\n\n        await client.stop()\n\n    # This event is triggered if you need to scan the QR code\n    @client.event(\"on_qr\")\n    async def on_qr(qr):\n        print(\"QR code scan is required. Please scan the QR in the browser.\")\n\n    await client.start()\n    print(\"Script finished.\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"api-reference/","title":"API Reference","text":"<p>This page provides an auto-generated API reference for the key components of the WhatsPlay library.</p>"},{"location":"api-reference/#client","title":"Client","text":"<p>The <code>Client</code> is the main entry point for interacting with WhatsApp.</p>"},{"location":"api-reference/#whatsplay.client.Client","title":"<code>whatsplay.client.Client</code>","text":"<p>               Bases: <code>BaseWhatsAppClient</code></p> <p>High-level WhatsApp Web client with full automation capabilities.</p> <p>This client provides a complete interface for WhatsApp Web automation including authentication, chat management, message sending, and event handling.</p> <p>Attributes:</p> Name Type Description <code>locale</code> <p>Locale for the browser (default: \"en-US\")</p> <code>poll_freq</code> <p>Frequency of state polling in seconds</p> <code>current_state</code> <code>Optional[State]</code> <p>Current WhatsApp Web state</p> <code>unread_messages_sleep</code> <p>Sleep time between unread message checks</p> <code>wa_elements</code> <code>Optional[WhatsAppElements]</code> <p>WhatsApp Web elements helper</p> <code>chat_manager</code> <code>Optional[ChatManager]</code> <p>Chat operations manager</p> <code>state_manager</code> <code>Optional[StateManager]</code> <p>State transition manager</p> Example <p>client = Client(auth=LocalProfileAuth(\"./session\")) @client.event(\"on_logged_in\") ... async def on_ready(): ...     print(\"Client is ready!\") await client.start()</p> Source code in <code>src/whatsplay/client.py</code> <pre><code>class Client(BaseWhatsAppClient):\n    \"\"\"\n    High-level WhatsApp Web client with full automation capabilities.\n\n    This client provides a complete interface for WhatsApp Web automation\n    including authentication, chat management, message sending, and event handling.\n\n    Attributes:\n        locale: Locale for the browser (default: \"en-US\")\n        poll_freq: Frequency of state polling in seconds\n        current_state: Current WhatsApp Web state\n        unread_messages_sleep: Sleep time between unread message checks\n        wa_elements: WhatsApp Web elements helper\n        chat_manager: Chat operations manager\n        state_manager: State transition manager\n\n    Example:\n        &gt;&gt;&gt; client = Client(auth=LocalProfileAuth(\"./session\"))\n        &gt;&gt;&gt; @client.event(\"on_logged_in\")\n        ... async def on_ready():\n        ...     print(\"Client is ready!\")\n        &gt;&gt;&gt; await client.start()\n    \"\"\"\n\n    def __init__(\n        self,\n        user_data_dir: Optional[str] = None,\n        headless: bool = False,\n        locale: str = \"en-US\",\n        auth: Optional[Any] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the WhatsApp Web client.\n\n        Args:\n            user_data_dir: Directory for browser profile data\n            headless: Run browser in headless mode\n            locale: Browser locale setting\n            auth: Authentication provider instance\n        \"\"\"\n        super().__init__(user_data_dir=user_data_dir, headless=headless, auth=auth)\n        self.locale = locale\n        self._cached_chats: set = set()\n        self.poll_freq = DEFAULT_POLL_FREQUENCY\n        self.wa_elements: Optional[WhatsAppElements] = None\n        self.qr_task: Optional[asyncio.Task] = None\n        self.current_state: Optional[State] = None\n        self.unread_messages_sleep = DEFAULT_UNREAD_MESSAGES_SLEEP\n        self._shutdown_event = asyncio.Event()\n        self._consecutive_errors = 0\n        self.last_qr_shown: Optional[bytes] = None\n        self.chat_manager: Optional[ChatManager] = None\n        self.state_manager: Optional[StateManager] = None\n        self._setup_signal_handlers()\n\n    def _setup_signal_handlers(self) -&gt; None:\n        \"\"\"\n        Configure signal handlers for clean shutdown.\n\n        Sets up handlers for SIGINT and SIGTERM to ensure proper cleanup\n        when the process is terminated.\n        \"\"\"\n        if sys.platform != \"win32\":\n            for sig in (signal.SIGINT, signal.SIGTERM):\n                try:\n                    asyncio.get_event_loop().add_signal_handler(\n                        sig, lambda s=sig: asyncio.create_task(self._handle_signal(s))\n                    )\n                except (NotImplementedError, RuntimeError):\n                    signal.signal(\n                        sig, lambda s, f: asyncio.create_task(self._handle_signal(s))\n                    )\n        else:\n            for sig in (signal.SIGINT, signal.SIGTERM):\n                signal.signal(\n                    sig, lambda s, f: asyncio.create_task(self._handle_signal(s))\n                )\n\n    async def _handle_signal(self, signum: int) -&gt; None:\n        \"\"\"\n        Handle system signals for graceful shutdown.\n\n        Args:\n            signum: Signal number received\n        \"\"\"\n        signame = (\n            signal.Signals(signum).name if hasattr(signal, \"Signals\") else str(signum)\n        )\n        print(f\"\\nReceived signal {signame}. Shutting down gracefully...\")\n        self._shutdown_event.set()\n        await self.stop()\n        sys.exit(0)\n\n    @property\n    def running(self) -&gt; bool:\n        \"\"\"Check if the client is currently running.\"\"\"\n        return getattr(self, \"_is_running\", False)\n\n    async def stop(self) -&gt; None:\n        \"\"\"\n        Stop the client and clean up resources.\n\n        This method ensures all resources are properly released including\n        browser instances, pages, and the Playwright instance.\n        \"\"\"\n        if not getattr(self, \"_is_running\", False):\n            return\n\n        self._is_running = False\n\n        try:\n            # Close page\n            if hasattr(self, \"_page\") and self._page:\n                try:\n                    await self._page.close()\n                except Exception as e:\n                    await self.emit(\"on_error\", f\"Error closing page: {e}\")\n                finally:\n                    self._page = None\n\n            # Call parent stop\n            await super().stop()\n\n            # Close browser\n            if hasattr(self, \"_browser\") and self._browser:\n                try:\n                    await self._browser.close()\n                except Exception as e:\n                    await self.emit(\"on_error\", f\"Error closing browser: {e}\")\n                finally:\n                    self._browser = None\n\n            # Stop playwright\n            if hasattr(self, \"playwright\") and self.playwright:\n                try:\n                    await self.playwright.stop()\n                except Exception as e:\n                    await self.emit(\"on_error\", f\"Error stopping Playwright: {e}\")\n                finally:\n                    self.playwright = None\n\n        except Exception as e:\n            await self.emit(\"on_error\", f\"Error during cleanup: {e}\")\n        finally:\n            await self.emit(\"on_stop\")\n            self._shutdown_event.set()\n\n    async def start(self) -&gt; None:\n        \"\"\"\n        Start the WhatsApp Web client.\n\n        Initializes all components and begins the main event loop.\n        This method will run until the client is stopped.\n\n        Raises:\n            Exception: If initialization or main loop fails\n        \"\"\"\n        try:\n            await super().start()\n            self.wa_elements = WhatsAppElements(self._page)\n            self.chat_manager = ChatManager(self)\n            self.state_manager = StateManager(self)\n            self._is_running = True\n            await self._main_loop()\n\n        except asyncio.CancelledError:\n            await self.emit(\"on_info\", \"Operation cancelled\")\n            raise\n        except Exception as e:\n            await self.emit(\"on_error\", f\"Error in main loop: {e}\")\n            raise\n        finally:\n            await self.stop()\n\n    async def _main_loop(self) -&gt; None:\n        \"\"\"\n        Initialize and start the main event loop.\n\n        Sets up initial state and begins monitoring WhatsApp Web.\n        \"\"\"\n        if not self._page:\n            await self.emit(\"on_error\", \"Could not initialize page\")\n            return\n\n        await self.emit(\"on_start\")\n\n        try:\n            await self._page.screenshot(path=\"init_main.png\", full_page=True)\n        except Exception as e:\n            await self.emit(\"on_warning\", f\"Could not take initial screenshot: {e}\")\n\n        await self._run_main_loop()\n\n    async def _run_main_loop(self) -&gt; None:\n        \"\"\"\n        Execute the main event loop.\n\n        Continuously monitors WhatsApp Web state and handles state transitions\n        until the client is stopped or encounters unrecoverable errors.\n        \"\"\"\n        state: Optional[State] = None\n\n        while self._is_running and not self._shutdown_event.is_set():\n            try:\n                curr_state = await self.state_manager._get_state()\n                self.current_state = curr_state\n\n                if curr_state is None:\n                    await asyncio.sleep(self.poll_freq)\n                    continue\n\n                if curr_state != state:\n                    await self.state_manager._handle_state_change(curr_state, state)\n                    state = curr_state\n                    self._consecutive_errors = 0  # Reset error counter on successful state change\n                else:\n                    await self.state_manager._handle_same_state(curr_state)\n\n                await self.emit(\"on_tick\")\n                await asyncio.sleep(self.poll_freq)\n\n            except asyncio.CancelledError:\n                await self.emit(\"on_info\", \"Main loop cancelled\")\n                raise\n\n            except Exception as e:\n                self._consecutive_errors += 1\n                await self.emit(\"on_error\", f\"Error in loop iteration: {e}\")\n                await asyncio.sleep(1)\n\n                if self._consecutive_errors &gt; MAX_CONSECUTIVE_ERRORS:\n                    await self.emit(\n                        \"on_warning\",\n                        \"Too many consecutive errors, attempting to reconnect...\",\n                    )\n                    try:\n                        await self.reconnect()\n                        self._consecutive_errors = 0\n                    except Exception as reconnect_error:\n                        await self.emit(\n                            \"on_error\", f\"Reconnection error: {reconnect_error}\"\n                        )\n                        break\n\n    async def wait_until_logged_in(self, timeout: int = DEFAULT_LOGIN_TIMEOUT) -&gt; bool:\n        \"\"\"\n        Wait until the client is logged in.\n\n        Args:\n            timeout: Maximum time to wait in seconds\n\n        Returns:\n            True if logged in within timeout, False otherwise\n        \"\"\"\n        start = time.time()\n        while time.time() - start &lt; timeout:\n            if self.current_state == State.LOGGED_IN:\n                return True\n            await asyncio.sleep(self.poll_freq)\n\n        await self.emit(\"on_error\", \"Login timeout expired\")\n        return False\n\n    # -------------------------------------------------------------------------\n    # Delegated methods to ChatManager\n    # -------------------------------------------------------------------------\n\n    async def close(self) -&gt; None:\n        \"\"\"Close the currently open chat.\"\"\"\n        return await self.chat_manager.close()\n\n    async def open(\n        self, chat_name: str, timeout: int = 10000, open_via_url: bool = False\n    ) -&gt; bool:\n        \"\"\"\n        Open a chat by name.\n\n        Args:\n            chat_name: Name of the chat to open\n            timeout: Maximum wait time in milliseconds\n            open_via_url: Force opening via URL (for phone numbers)\n\n        Returns:\n            True if chat was opened successfully\n        \"\"\"\n        return await self.chat_manager.open(chat_name, timeout, open_via_url=open_via_url)\n\n    async def search_conversations(\n        self, query: str, close: bool = True\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Search for conversations.\n\n        Args:\n            query: Search term\n            close: Close search after completion\n\n        Returns:\n            List of matching conversations\n        \"\"\"\n        return await self.chat_manager.search_conversations(query, close)\n\n    async def collect_messages(self) -&gt; List[Union[Message, FileMessage]]:\n        \"\"\"\n        Collect all visible messages in the current chat.\n\n        Returns:\n            List of Message and FileMessage objects\n        \"\"\"\n        return await self.chat_manager.collect_messages()\n\n    async def download_all_files(self, carpeta: Optional[str] = None) -&gt; List[Path]:\n        \"\"\"\n        Download all files from the current chat.\n\n        Args:\n            carpeta: Optional custom download directory\n\n        Returns:\n            List of paths to downloaded files\n        \"\"\"\n        return await self.chat_manager.download_all_files(carpeta)\n\n    async def download_file_by_index(\n        self, index: int, carpeta: Optional[str] = None\n    ) -&gt; Optional[Path]:\n        \"\"\"\n        Download a specific file by index.\n\n        Args:\n            index: Zero-based file index\n            carpeta: Optional custom download directory\n\n        Returns:\n            Path to downloaded file or None if failed\n        \"\"\"\n        return await self.chat_manager.download_file_by_index(index, carpeta)\n\n    async def send_message(\n        self, chat_query: str, message: str, open_via_url: bool = False\n    ) -&gt; bool:\n        \"\"\"\n        Send a text message.\n\n        Args:\n            chat_query: Chat name or identifier\n            message: Message text to send\n            open_via_url: Open chat via URL before sending\n\n        Returns:\n            True if message was sent successfully\n        \"\"\"\n        return await self.chat_manager.send_message(chat_query, message, open_via_url=open_via_url)\n\n    async def send_file(self, chat_name: str, path: str) -&gt; bool:\n        \"\"\"\n        Send a file attachment.\n\n        Args:\n            chat_name: Name of the chat\n            path: Absolute path to the file\n\n        Returns:\n            True if file was sent successfully\n        \"\"\"\n        return await self.chat_manager.send_file(chat_name, path)\n\n    async def react_to_last_message(self, emoji: str) -&gt; bool:\n        \"\"\"\n        React to the last visible message in the current chat.\n\n        Args:\n            emoji: The emoji to react with (e.g., \"\ud83d\udc4d\", \"\u2764\ufe0f\")\n\n        Returns:\n            True if reaction was successful\n        \"\"\"\n        return await self.chat_manager.react_to_last_message(emoji)\n\n    async def new_group(self, group_name: str, members: List[str]) -&gt; bool:\n        \"\"\"\n        Create a new group.\n\n        Args:\n            group_name: Name for the new group\n            members: List of member names\n\n        Returns:\n            True if group was created successfully\n        \"\"\"\n        return await self.wa_elements.new_group(group_name, members)\n\n    async def add_members_to_group(\n        self, group_name: str, members: List[str]\n    ) -&gt; bool:\n        \"\"\"\n        Add members to an existing group.\n\n        Args:\n            group_name: Name of the group\n            members: List of member names to add\n\n        Returns:\n            True if members were added successfully\n        \"\"\"\n        return await self.wa_elements.add_members_to_group(group_name, members)\n\n    async def del_members_from_group(\n        self, group_name: str, members: List[str]\n    ) -&gt; bool:\n        \"\"\"\n        Remove members from a group.\n\n        Args:\n            group_name: Name of the group\n            members: List of member names to remove\n\n        Returns:\n            True if members were removed successfully\n        \"\"\"\n        return await self.wa_elements.del_member_group(group_name, members)\n</code></pre>"},{"location":"api-reference/#whatsplay.client.Client.running","title":"<code>running</code>  <code>property</code>","text":"<p>Check if the client is currently running.</p>"},{"location":"api-reference/#whatsplay.client.Client.__init__","title":"<code>__init__(user_data_dir=None, headless=False, locale='en-US', auth=None)</code>","text":"<p>Initialize the WhatsApp Web client.</p> <p>Parameters:</p> Name Type Description Default <code>user_data_dir</code> <code>Optional[str]</code> <p>Directory for browser profile data</p> <code>None</code> <code>headless</code> <code>bool</code> <p>Run browser in headless mode</p> <code>False</code> <code>locale</code> <code>str</code> <p>Browser locale setting</p> <code>'en-US'</code> <code>auth</code> <code>Optional[Any]</code> <p>Authentication provider instance</p> <code>None</code> Source code in <code>src/whatsplay/client.py</code> <pre><code>def __init__(\n    self,\n    user_data_dir: Optional[str] = None,\n    headless: bool = False,\n    locale: str = \"en-US\",\n    auth: Optional[Any] = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the WhatsApp Web client.\n\n    Args:\n        user_data_dir: Directory for browser profile data\n        headless: Run browser in headless mode\n        locale: Browser locale setting\n        auth: Authentication provider instance\n    \"\"\"\n    super().__init__(user_data_dir=user_data_dir, headless=headless, auth=auth)\n    self.locale = locale\n    self._cached_chats: set = set()\n    self.poll_freq = DEFAULT_POLL_FREQUENCY\n    self.wa_elements: Optional[WhatsAppElements] = None\n    self.qr_task: Optional[asyncio.Task] = None\n    self.current_state: Optional[State] = None\n    self.unread_messages_sleep = DEFAULT_UNREAD_MESSAGES_SLEEP\n    self._shutdown_event = asyncio.Event()\n    self._consecutive_errors = 0\n    self.last_qr_shown: Optional[bytes] = None\n    self.chat_manager: Optional[ChatManager] = None\n    self.state_manager: Optional[StateManager] = None\n    self._setup_signal_handlers()\n</code></pre>"},{"location":"api-reference/#whatsplay.client.Client.add_members_to_group","title":"<code>add_members_to_group(group_name, members)</code>  <code>async</code>","text":"<p>Add members to an existing group.</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>Name of the group</p> required <code>members</code> <code>List[str]</code> <p>List of member names to add</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if members were added successfully</p> Source code in <code>src/whatsplay/client.py</code> <pre><code>async def add_members_to_group(\n    self, group_name: str, members: List[str]\n) -&gt; bool:\n    \"\"\"\n    Add members to an existing group.\n\n    Args:\n        group_name: Name of the group\n        members: List of member names to add\n\n    Returns:\n        True if members were added successfully\n    \"\"\"\n    return await self.wa_elements.add_members_to_group(group_name, members)\n</code></pre>"},{"location":"api-reference/#whatsplay.client.Client.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close the currently open chat.</p> Source code in <code>src/whatsplay/client.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the currently open chat.\"\"\"\n    return await self.chat_manager.close()\n</code></pre>"},{"location":"api-reference/#whatsplay.client.Client.collect_messages","title":"<code>collect_messages()</code>  <code>async</code>","text":"<p>Collect all visible messages in the current chat.</p> <p>Returns:</p> Type Description <code>List[Union[Message, FileMessage]]</code> <p>List of Message and FileMessage objects</p> Source code in <code>src/whatsplay/client.py</code> <pre><code>async def collect_messages(self) -&gt; List[Union[Message, FileMessage]]:\n    \"\"\"\n    Collect all visible messages in the current chat.\n\n    Returns:\n        List of Message and FileMessage objects\n    \"\"\"\n    return await self.chat_manager.collect_messages()\n</code></pre>"},{"location":"api-reference/#whatsplay.client.Client.del_members_from_group","title":"<code>del_members_from_group(group_name, members)</code>  <code>async</code>","text":"<p>Remove members from a group.</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>Name of the group</p> required <code>members</code> <code>List[str]</code> <p>List of member names to remove</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if members were removed successfully</p> Source code in <code>src/whatsplay/client.py</code> <pre><code>async def del_members_from_group(\n    self, group_name: str, members: List[str]\n) -&gt; bool:\n    \"\"\"\n    Remove members from a group.\n\n    Args:\n        group_name: Name of the group\n        members: List of member names to remove\n\n    Returns:\n        True if members were removed successfully\n    \"\"\"\n    return await self.wa_elements.del_member_group(group_name, members)\n</code></pre>"},{"location":"api-reference/#whatsplay.client.Client.download_all_files","title":"<code>download_all_files(carpeta=None)</code>  <code>async</code>","text":"<p>Download all files from the current chat.</p> <p>Parameters:</p> Name Type Description Default <code>carpeta</code> <code>Optional[str]</code> <p>Optional custom download directory</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Path]</code> <p>List of paths to downloaded files</p> Source code in <code>src/whatsplay/client.py</code> <pre><code>async def download_all_files(self, carpeta: Optional[str] = None) -&gt; List[Path]:\n    \"\"\"\n    Download all files from the current chat.\n\n    Args:\n        carpeta: Optional custom download directory\n\n    Returns:\n        List of paths to downloaded files\n    \"\"\"\n    return await self.chat_manager.download_all_files(carpeta)\n</code></pre>"},{"location":"api-reference/#whatsplay.client.Client.download_file_by_index","title":"<code>download_file_by_index(index, carpeta=None)</code>  <code>async</code>","text":"<p>Download a specific file by index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Zero-based file index</p> required <code>carpeta</code> <code>Optional[str]</code> <p>Optional custom download directory</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Path]</code> <p>Path to downloaded file or None if failed</p> Source code in <code>src/whatsplay/client.py</code> <pre><code>async def download_file_by_index(\n    self, index: int, carpeta: Optional[str] = None\n) -&gt; Optional[Path]:\n    \"\"\"\n    Download a specific file by index.\n\n    Args:\n        index: Zero-based file index\n        carpeta: Optional custom download directory\n\n    Returns:\n        Path to downloaded file or None if failed\n    \"\"\"\n    return await self.chat_manager.download_file_by_index(index, carpeta)\n</code></pre>"},{"location":"api-reference/#whatsplay.client.Client.new_group","title":"<code>new_group(group_name, members)</code>  <code>async</code>","text":"<p>Create a new group.</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>Name for the new group</p> required <code>members</code> <code>List[str]</code> <p>List of member names</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if group was created successfully</p> Source code in <code>src/whatsplay/client.py</code> <pre><code>async def new_group(self, group_name: str, members: List[str]) -&gt; bool:\n    \"\"\"\n    Create a new group.\n\n    Args:\n        group_name: Name for the new group\n        members: List of member names\n\n    Returns:\n        True if group was created successfully\n    \"\"\"\n    return await self.wa_elements.new_group(group_name, members)\n</code></pre>"},{"location":"api-reference/#whatsplay.client.Client.open","title":"<code>open(chat_name, timeout=10000, open_via_url=False)</code>  <code>async</code>","text":"<p>Open a chat by name.</p> <p>Parameters:</p> Name Type Description Default <code>chat_name</code> <code>str</code> <p>Name of the chat to open</p> required <code>timeout</code> <code>int</code> <p>Maximum wait time in milliseconds</p> <code>10000</code> <code>open_via_url</code> <code>bool</code> <p>Force opening via URL (for phone numbers)</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if chat was opened successfully</p> Source code in <code>src/whatsplay/client.py</code> <pre><code>async def open(\n    self, chat_name: str, timeout: int = 10000, open_via_url: bool = False\n) -&gt; bool:\n    \"\"\"\n    Open a chat by name.\n\n    Args:\n        chat_name: Name of the chat to open\n        timeout: Maximum wait time in milliseconds\n        open_via_url: Force opening via URL (for phone numbers)\n\n    Returns:\n        True if chat was opened successfully\n    \"\"\"\n    return await self.chat_manager.open(chat_name, timeout, open_via_url=open_via_url)\n</code></pre>"},{"location":"api-reference/#whatsplay.client.Client.react_to_last_message","title":"<code>react_to_last_message(emoji)</code>  <code>async</code>","text":"<p>React to the last visible message in the current chat.</p> <p>Parameters:</p> Name Type Description Default <code>emoji</code> <code>str</code> <p>The emoji to react with (e.g., \"\ud83d\udc4d\", \"\u2764\ufe0f\")</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if reaction was successful</p> Source code in <code>src/whatsplay/client.py</code> <pre><code>async def react_to_last_message(self, emoji: str) -&gt; bool:\n    \"\"\"\n    React to the last visible message in the current chat.\n\n    Args:\n        emoji: The emoji to react with (e.g., \"\ud83d\udc4d\", \"\u2764\ufe0f\")\n\n    Returns:\n        True if reaction was successful\n    \"\"\"\n    return await self.chat_manager.react_to_last_message(emoji)\n</code></pre>"},{"location":"api-reference/#whatsplay.client.Client.search_conversations","title":"<code>search_conversations(query, close=True)</code>  <code>async</code>","text":"<p>Search for conversations.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Search term</p> required <code>close</code> <code>bool</code> <p>Close search after completion</p> <code>True</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of matching conversations</p> Source code in <code>src/whatsplay/client.py</code> <pre><code>async def search_conversations(\n    self, query: str, close: bool = True\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Search for conversations.\n\n    Args:\n        query: Search term\n        close: Close search after completion\n\n    Returns:\n        List of matching conversations\n    \"\"\"\n    return await self.chat_manager.search_conversations(query, close)\n</code></pre>"},{"location":"api-reference/#whatsplay.client.Client.send_file","title":"<code>send_file(chat_name, path)</code>  <code>async</code>","text":"<p>Send a file attachment.</p> <p>Parameters:</p> Name Type Description Default <code>chat_name</code> <code>str</code> <p>Name of the chat</p> required <code>path</code> <code>str</code> <p>Absolute path to the file</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if file was sent successfully</p> Source code in <code>src/whatsplay/client.py</code> <pre><code>async def send_file(self, chat_name: str, path: str) -&gt; bool:\n    \"\"\"\n    Send a file attachment.\n\n    Args:\n        chat_name: Name of the chat\n        path: Absolute path to the file\n\n    Returns:\n        True if file was sent successfully\n    \"\"\"\n    return await self.chat_manager.send_file(chat_name, path)\n</code></pre>"},{"location":"api-reference/#whatsplay.client.Client.send_message","title":"<code>send_message(chat_query, message, open_via_url=False)</code>  <code>async</code>","text":"<p>Send a text message.</p> <p>Parameters:</p> Name Type Description Default <code>chat_query</code> <code>str</code> <p>Chat name or identifier</p> required <code>message</code> <code>str</code> <p>Message text to send</p> required <code>open_via_url</code> <code>bool</code> <p>Open chat via URL before sending</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if message was sent successfully</p> Source code in <code>src/whatsplay/client.py</code> <pre><code>async def send_message(\n    self, chat_query: str, message: str, open_via_url: bool = False\n) -&gt; bool:\n    \"\"\"\n    Send a text message.\n\n    Args:\n        chat_query: Chat name or identifier\n        message: Message text to send\n        open_via_url: Open chat via URL before sending\n\n    Returns:\n        True if message was sent successfully\n    \"\"\"\n    return await self.chat_manager.send_message(chat_query, message, open_via_url=open_via_url)\n</code></pre>"},{"location":"api-reference/#whatsplay.client.Client.start","title":"<code>start()</code>  <code>async</code>","text":"<p>Start the WhatsApp Web client.</p> <p>Initializes all components and begins the main event loop. This method will run until the client is stopped.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If initialization or main loop fails</p> Source code in <code>src/whatsplay/client.py</code> <pre><code>async def start(self) -&gt; None:\n    \"\"\"\n    Start the WhatsApp Web client.\n\n    Initializes all components and begins the main event loop.\n    This method will run until the client is stopped.\n\n    Raises:\n        Exception: If initialization or main loop fails\n    \"\"\"\n    try:\n        await super().start()\n        self.wa_elements = WhatsAppElements(self._page)\n        self.chat_manager = ChatManager(self)\n        self.state_manager = StateManager(self)\n        self._is_running = True\n        await self._main_loop()\n\n    except asyncio.CancelledError:\n        await self.emit(\"on_info\", \"Operation cancelled\")\n        raise\n    except Exception as e:\n        await self.emit(\"on_error\", f\"Error in main loop: {e}\")\n        raise\n    finally:\n        await self.stop()\n</code></pre>"},{"location":"api-reference/#whatsplay.client.Client.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Stop the client and clean up resources.</p> <p>This method ensures all resources are properly released including browser instances, pages, and the Playwright instance.</p> Source code in <code>src/whatsplay/client.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"\n    Stop the client and clean up resources.\n\n    This method ensures all resources are properly released including\n    browser instances, pages, and the Playwright instance.\n    \"\"\"\n    if not getattr(self, \"_is_running\", False):\n        return\n\n    self._is_running = False\n\n    try:\n        # Close page\n        if hasattr(self, \"_page\") and self._page:\n            try:\n                await self._page.close()\n            except Exception as e:\n                await self.emit(\"on_error\", f\"Error closing page: {e}\")\n            finally:\n                self._page = None\n\n        # Call parent stop\n        await super().stop()\n\n        # Close browser\n        if hasattr(self, \"_browser\") and self._browser:\n            try:\n                await self._browser.close()\n            except Exception as e:\n                await self.emit(\"on_error\", f\"Error closing browser: {e}\")\n            finally:\n                self._browser = None\n\n        # Stop playwright\n        if hasattr(self, \"playwright\") and self.playwright:\n            try:\n                await self.playwright.stop()\n            except Exception as e:\n                await self.emit(\"on_error\", f\"Error stopping Playwright: {e}\")\n            finally:\n                self.playwright = None\n\n    except Exception as e:\n        await self.emit(\"on_error\", f\"Error during cleanup: {e}\")\n    finally:\n        await self.emit(\"on_stop\")\n        self._shutdown_event.set()\n</code></pre>"},{"location":"api-reference/#whatsplay.client.Client.wait_until_logged_in","title":"<code>wait_until_logged_in(timeout=DEFAULT_LOGIN_TIMEOUT)</code>  <code>async</code>","text":"<p>Wait until the client is logged in.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>Maximum time to wait in seconds</p> <code>DEFAULT_LOGIN_TIMEOUT</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if logged in within timeout, False otherwise</p> Source code in <code>src/whatsplay/client.py</code> <pre><code>async def wait_until_logged_in(self, timeout: int = DEFAULT_LOGIN_TIMEOUT) -&gt; bool:\n    \"\"\"\n    Wait until the client is logged in.\n\n    Args:\n        timeout: Maximum time to wait in seconds\n\n    Returns:\n        True if logged in within timeout, False otherwise\n    \"\"\"\n    start = time.time()\n    while time.time() - start &lt; timeout:\n        if self.current_state == State.LOGGED_IN:\n            return True\n        await asyncio.sleep(self.poll_freq)\n\n    await self.emit(\"on_error\", \"Login timeout expired\")\n    return False\n</code></pre>"},{"location":"api-reference/#events","title":"Events","text":"<p>These events are emitted by the <code>Client</code> and can be handled using the <code>@client.event</code> decorator.</p> Event Name Trigger Condition Arguments <code>on_start</code> The client has successfully initialized and the browser page is open. None <code>on_auth</code> The authentication screen (QR code page) is displayed. None <code>on_qr</code> A new QR code is detected for the first time. <code>qr_binary</code> (bytes) <code>on_qr_change</code> The displayed QR code has been refreshed/changed. <code>qr_binary</code> (bytes) <code>on_logged_in</code> The client has successfully logged in to WhatsApp Web. None <code>on_loading</code> The \"Loading chats\" screen is visible. <code>is_loading</code> (bool) <code>on_unread_chat</code> Unread chats are detected in the sidebar. This check runs periodically. <code>chats</code> (List[Dict]) <code>on_stop</code> The client is stopping and cleaning up resources. None <code>on_disconnect</code> The client has lost connection to the browser/WhatsApp. None <code>on_reconnect</code> The client has successfully reconnected. None <code>on_state_change</code> The client's internal state (e.g., AUTH, LOGGED_IN) has changed. <code>state</code> (State enum) <code>on_tick</code> Emitted on every iteration of the main event loop. None <code>on_error</code> An error occurred. <code>message</code> (str) <code>on_warning</code> A non-critical issue occurred. <code>message</code> (str) <code>on_info</code> Informational message. <code>message</code> (str) <p>Note: The <code>on_message</code> event is reserved for future use. Currently, use <code>on_unread_chat</code> to detect new activity.</p>"},{"location":"api-reference/#event-objects","title":"Event Objects","text":"<p>These are the objects passed to your event handlers.</p>"},{"location":"api-reference/#message","title":"Message","text":"<p>The <code>Message</code> object represents a message retrieved from a chat (e.g., via <code>chat_manager.collect_messages()</code>).</p>"},{"location":"api-reference/#whatsplay.object.message.Message","title":"<code>whatsplay.object.message.Message</code>","text":"Source code in <code>src/whatsplay/object/message.py</code> <pre><code>class Message:\n    def __init__(self, page: Page, sender: str, timestamp: datetime, text: str, container: ElementHandle,\n                 is_outgoing: bool = False, msg_id: str = \"\"):\n        self.page = page\n        self.sender = sender\n        self.timestamp = timestamp\n        self.text = text\n        self.container = container\n        self.is_outgoing = is_outgoing\n        self.msg_id = msg_id\n\n    @classmethod\n    async def from_element(cls, elem: ElementHandle, page: Page) -&gt; Optional[\"Message\"]:\n        try:\n            # 0) Direcci\u00f3n (in/out) e ID si existe\n            classes = (await elem.get_attribute(\"class\")) or \"\"\n            is_outgoing = \"message-out\" in classes  # entrante: message-in\n            msg_id = (await elem.get_attribute(\"data-id\")) or \"\"\n\n            # 1) remitente\n            sender = \"\"\n            remitente_span = await elem.query_selector(\n                'xpath=.//span[@aria-label and substring(@aria-label, string-length(@aria-label))=\":\"]'\n            )\n            if remitente_span:\n                raw_label = await remitente_span.get_attribute(\"aria-label\")\n                if raw_label:\n                    sender = raw_label.rstrip(\":\").strip()\n\n            # 2) hora\n            timestamp = datetime.now()\n            time_span = await elem.query_selector('xpath=.//span[contains(@class,\"x16dsc37\")]')\n            if time_span:\n                hora_text = (await time_span.inner_text()).strip().lower()\n                # Formatos esperados: \"10:30\", \"10:30 am\", \"10:30 p.m.\"\n                match = re.match(r'(\\d{1,2}):(\\d{2})\\s*(a\\.?m\\.?|p\\.?m\\.?|)?', hora_text)\n                if match:\n                    hh = int(match.group(1))\n                    mm = int(match.group(2))\n                    ampm = (match.group(3) or \"\").replace(\".\", \"\")\n\n                    if ampm == 'pm' and hh != 12:\n                        hh += 12\n                    elif ampm == 'am' and hh == 12: # Medianoche\n                        hh = 0\n\n                    ahora = datetime.now()\n                    timestamp = ahora.replace(hour=hh, minute=mm, second=0, microsecond=0)\n\n            # 3) texto\n            texto = \"\"\n            cuerpo_div = await elem.query_selector('xpath=.//div[contains(@class,\"copyable-text\")]/div')\n            if cuerpo_div:\n                raw_inner = await cuerpo_div.inner_text()\n                if raw_inner:\n                    lineas = raw_inner.split(\"\\n\")\n                    if len(lineas) &gt; 1 and (lineas[0].strip().startswith(sender) or \":\" in lineas[0]):\n                        texto = \"\\n\".join(lineas[1:]).strip()\n                    else:\n                        texto = raw_inner.strip()\n\n            return cls(\n                page=page, sender=sender, timestamp=timestamp, text=texto, container=elem,\n                is_outgoing=is_outgoing, msg_id=msg_id\n            )\n        except Exception:\n            return None\n\n    async def react(self, emoji: str):\n        \"\"\"\n        Reacts to this message with the given emoji, following the user-verified workflow.\n        \"\"\"\n\n        try:\n            # 1. Hover over the message to make the action bar appear.\n            await self.container.hover()\n\n            # Take screenshot after hover\n            await self.container.screenshot(path=\"after_hover.png\")\n            print(\"self.container: \", self.container)\n            await asyncio.sleep(1.5)\n            input(\"presiona enter para continuar\")\n\n            # 2. The user confirmed a button with aria-label=\"Reaccionar\" appears first.\n            # We wait for it to ensure the hover menu is open.\n            # This is likely the default reaction button, but it makes the '+' button visible.\n            reaction_bar = self.page.locator('[aria-label=\"Reaccionar\"]')\n            if not reaction_bar:\n                print(\"Error: No se encontr\u00f3 el bot\u00f3n '[aria-label=\\\"Reaccionar\\\"]'.\")\n                return None\n            await reaction_bar.click()\n\n            # 3. The user confirmed they must then click a button with aria-label=\"M\u00e1s reacciones\" to open the picker.\n            more_reactions_button_handle = self.page.locator('[aria-label=\"M\u00e1s reacciones\"]')\n            if not more_reactions_button_handle:\n                print(\"Error: No se encontr\u00f3 el bot\u00f3n '[aria-label=\\\"M\u00e1s reacciones\\\"]'.\")\n                return None\n\n            await more_reactions_button_handle.click()\n\n            # 4. The emoji picker appears on the main page. We now use the main page object.\n            # We also use the correct selector for emojis, which is their aria-label.\n\n            # The selector finds the picker and then the specific emoji inside it.\n            emoji_in_picker = self.page.locator(f'[data-emoji=\"{emoji}\"]')\n\n            # 5. Wait for the emoji to be visible and click it.\n            await emoji_in_picker.wait_for(state=\"visible\", timeout=5000)\n            await emoji_in_picker.click()\n\n            print(f\"Successfully reacted with '{emoji}'\")\n\n        except Exception as e:\n            print(f\"An error occurred while reacting to message {self.msg_id}: {e}\")\n</code></pre>"},{"location":"api-reference/#whatsplay.object.message.Message.react","title":"<code>react(emoji)</code>  <code>async</code>","text":"<p>Reacts to this message with the given emoji, following the user-verified workflow.</p> Source code in <code>src/whatsplay/object/message.py</code> <pre><code>async def react(self, emoji: str):\n    \"\"\"\n    Reacts to this message with the given emoji, following the user-verified workflow.\n    \"\"\"\n\n    try:\n        # 1. Hover over the message to make the action bar appear.\n        await self.container.hover()\n\n        # Take screenshot after hover\n        await self.container.screenshot(path=\"after_hover.png\")\n        print(\"self.container: \", self.container)\n        await asyncio.sleep(1.5)\n        input(\"presiona enter para continuar\")\n\n        # 2. The user confirmed a button with aria-label=\"Reaccionar\" appears first.\n        # We wait for it to ensure the hover menu is open.\n        # This is likely the default reaction button, but it makes the '+' button visible.\n        reaction_bar = self.page.locator('[aria-label=\"Reaccionar\"]')\n        if not reaction_bar:\n            print(\"Error: No se encontr\u00f3 el bot\u00f3n '[aria-label=\\\"Reaccionar\\\"]'.\")\n            return None\n        await reaction_bar.click()\n\n        # 3. The user confirmed they must then click a button with aria-label=\"M\u00e1s reacciones\" to open the picker.\n        more_reactions_button_handle = self.page.locator('[aria-label=\"M\u00e1s reacciones\"]')\n        if not more_reactions_button_handle:\n            print(\"Error: No se encontr\u00f3 el bot\u00f3n '[aria-label=\\\"M\u00e1s reacciones\\\"]'.\")\n            return None\n\n        await more_reactions_button_handle.click()\n\n        # 4. The emoji picker appears on the main page. We now use the main page object.\n        # We also use the correct selector for emojis, which is their aria-label.\n\n        # The selector finds the picker and then the specific emoji inside it.\n        emoji_in_picker = self.page.locator(f'[data-emoji=\"{emoji}\"]')\n\n        # 5. Wait for the emoji to be visible and click it.\n        await emoji_in_picker.wait_for(state=\"visible\", timeout=5000)\n        await emoji_in_picker.click()\n\n        print(f\"Successfully reacted with '{emoji}'\")\n\n    except Exception as e:\n        print(f\"An error occurred while reacting to message {self.msg_id}: {e}\")\n</code></pre>"},{"location":"api-reference/#managers","title":"Managers","text":"<p>Internal managers that handle different aspects of the client's functionality.</p>"},{"location":"api-reference/#chat-manager","title":"Chat Manager","text":"<p>Responsible for finding and managing chats.</p>"},{"location":"api-reference/#whatsplay.chat_manager.ChatManager","title":"<code>whatsplay.chat_manager.ChatManager</code>","text":"<p>Manages chat operations for WhatsApp Web.</p> <p>This class handles all chat-related operations including: - Opening and closing chats - Searching for conversations - Sending messages and files - Detecting unread chats - Downloading files from chats - Managing group operations</p> <p>Attributes:</p> Name Type Description <code>client</code> <p>Reference to the main WhatsApp client</p> <code>_page</code> <p>Playwright page object for browser interactions</p> <code>wa_elements</code> <p>WhatsApp Web elements helper</p> Source code in <code>src/whatsplay/chat_manager.py</code> <pre><code>class ChatManager:\n    \"\"\"\n    Manages chat operations for WhatsApp Web.\n\n    This class handles all chat-related operations including:\n    - Opening and closing chats\n    - Searching for conversations\n    - Sending messages and files\n    - Detecting unread chats\n    - Downloading files from chats\n    - Managing group operations\n\n    Attributes:\n        client: Reference to the main WhatsApp client\n        _page: Playwright page object for browser interactions\n        wa_elements: WhatsApp Web elements helper\n    \"\"\"\n\n    def __init__(self, client: \"Client\") -&gt; None:\n        \"\"\"\n        Initialize ChatManager with client reference.\n\n        Args:\n            client: The main WhatsApp client instance\n        \"\"\"\n        self.client = client\n        self._page = client._page\n        self.wa_elements = client.wa_elements\n\n    async def _check_unread_chats(self, debug: bool = True) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Detect all unread chats in the sidebar.\n\n        This method scans the chat list to identify unread messages using multiple\n        heuristics including aria-labels, badges, and font weight detection.\n\n        Args:\n            debug: If True, prints debug information during execution\n\n        Returns:\n            List of dictionaries containing unread chat information\n\n        Note:\n            The method uses multiple detection strategies:\n            1. aria-label matching for 'unread' or 'mensaje(s) no le\u00eddo'\n            2. Explicit unread badge detection\n            3. Bold font weight detection on chat titles\n        \"\"\"\n        unread_chats: List[Dict[str, Any]] = []\n        await self.close()  # Ensure no chat is currently open\n\n        def log(msg: str) -&gt; None:\n            \"\"\"Log debug messages if debug mode is enabled.\"\"\"\n            if debug:\n                print(msg)\n\n        async def _wait_for_grid() -&gt; None:\n            \"\"\"Wait for the chat grid to be present and hydrated.\"\"\"\n            try:\n                await self._page.locator(loc.CHAT_LIST_GRID).wait_for(timeout=15000)\n            except Exception:\n                await self._page.wait_for_timeout(1000)\n\n        async def _get_scroller_handle():\n            \"\"\"\n            Get the ElementHandle of the actual scrolling container.\n\n            Returns:\n                ElementHandle for the virtualizable scrolling container\n            \"\"\"\n            grid = self._page.locator(loc.CHAT_LIST_GRID)\n            grid_h = await grid.element_handle()\n\n            if not grid_h:\n                return await self._page.locator(\"#pane-side\").element_handle()\n\n            return await grid_h.evaluate_handle(\n                \"\"\"(el) =&gt; {\n                    let cur = el;\n                    while (cur &amp;&amp; cur !== document.body) {\n                        const s = getComputedStyle(cur);\n                        if ((s.overflowY === 'auto' || s.overflowY === 'scroll') &amp;&amp;\n                            cur.clientHeight &lt; cur.scrollHeight) return cur;\n                        cur = cur.parentElement;\n                    }\n                    return document.querySelector('#pane-side');\n                }\"\"\"\n            )\n\n        async def _is_row_unread(row_loc) -&gt; bool:\n            \"\"\"\n            Determine if a chat row represents an unread conversation.\n\n            Uses multiple detection strategies:\n            1. aria-label with 'unread' or 'mensaje(s) no le\u00eddo'\n            2. Explicit unread badge\n            3. Bold font weight on title (&gt;= 600)\n\n            Args:\n                row_loc: Locator for the chat row\n\n            Returns:\n                True if the chat is unread, False otherwise\n            \"\"\"\n            try:\n                # Strategy 1: Check aria-label for unread indicators\n                has_aria = await row_loc.locator(\"[aria-label]\").evaluate_all(\n                    \"(els, rx) =&gt; els.some(el =&gt; (el.getAttribute('aria-label')||'').match(new RegExp(rx,'i')))\",\n                    UNREAD_ARIA_PATTERN,\n                )\n                if has_aria:\n                    return True\n\n                # Strategy 2: Check for explicit unread badge\n                try:\n                    if await row_loc.locator(f\"xpath={loc.UNREAD_BADGE}\").count() &gt; 0:\n                        return True\n                except Exception:\n                    pass\n\n                # Strategy 3: Check for bold font weight on title\n                title = row_loc.locator(f\"xpath={loc.SPAN_TITLE}\")\n                if await title.count() == 0:\n                    return False\n\n                is_bold = await title.evaluate(\n                    \"\"\"(el) =&gt; {\n                        const w = getComputedStyle(el).fontWeight;\n                        const n = parseInt(w, 10);\n                        return isNaN(n) ? /bold/i.test(w) : n &gt;= 600;\n                    }\"\"\"\n                )\n                return bool(is_bold)\n\n            except Exception:\n                return False\n\n        async def _parse_row(row_loc):\n            \"\"\"\n            Parse a chat row into structured data.\n\n            Args:\n                row_loc: Locator for the chat row\n\n            Returns:\n                Dictionary with chat information or None if parsing fails\n            \"\"\"\n            handle = await row_loc.element_handle()\n            if not handle:\n                return None\n            return await self._parse_search_result(handle, \"CHATS\")\n\n        try:\n            # Step 0: Wait for UI to be ready\n            await _wait_for_grid()\n\n            # Step 1: Debug initial state\n            try:\n                total_rows_now = await self._page.locator(\n                    f\"xpath={loc.CHAT_LIST_ROWS}\"\n                ).count()\n                log(f\"DEBUG: Initially visible rows: {total_rows_now}\")\n\n                if total_rows_now &lt;= MIN_VISIBLE_CHATS_THRESHOLD:\n                    await self._page.locator(loc.ALL_CHATS_BUTTON).click()\n                    log(\"DEBUG: Few chats visible, clicking 'All' button\")\n                    log(\"DEBUG: Taking screenshot of low chat count state\")\n                    await self._page.screenshot(path=\"pocos_chats_visibles.png\")\n\n            except Exception:\n                log(\"DEBUG: Could not count initial rows\")\n\n            # Step 2: Get correct scroller for virtualized list\n            scroller_h = await _get_scroller_handle()\n\n            # Step 3: Sweep visible rows\n            async def sweep(tag: str) -&gt; None:\n                \"\"\"\n                Scan visible chat rows for unread messages.\n\n                Args:\n                    tag: Label for this sweep operation (for debugging)\n                \"\"\"\n                nonlocal unread_chats\n                rows = self._page.locator(f\"xpath={loc.CHAT_LIST_ROWS}\")\n                count = await rows.count()\n                log(f\"DEBUG: {tag}: Currently visible rows: {count}\")\n\n                for i in range(count):\n                    row = rows.nth(i)\n                    try:\n                        if await _is_row_unread(row):\n                            chat = await _parse_row(row)\n                            if chat:\n                                unread_chats.append(chat)\n                                log(f\"\u2713 Unread ({tag}): {chat.get('name', 'No name')}\")\n                    except Exception as e:\n                        log(f\"DEBUG: Error evaluating row {i} ({tag}): {e}\")\n\n            # Step 4: Initial sweep\n            await sweep(\"initial\")\n\n            # Step 5: Deduplication\n            def _get_chat_key(ch: Dict[str, Any]) -&gt; tuple:\n                \"\"\"Generate a unique key for a chat to enable deduplication.\"\"\"\n                return ch.get(\"id\") or (\n                    ch.get(\"name\"),\n                    ch.get(\"last_message\"),\n                    ch.get(\"last_activity\"),\n                )\n\n            seen = set()\n            dedup = []\n            for ch in unread_chats:\n                k = _get_chat_key(ch)\n                if k in seen:\n                    continue\n                seen.add(k)\n                dedup.append(ch)\n            unread_chats = dedup\n\n        except Exception as e:\n            await self.client.emit(\"on_warning\", f\"Error detecting unread chats: {e}\")\n            log(f\"DEBUG: General error: {e}\")\n\n        # Step 6: Final summary\n        log(\"\\nDEBUG: ===== SUMMARY =====\")\n        log(f\"Total unread chats found: {len(unread_chats)}\")\n        for i, chat in enumerate(unread_chats, 1):\n            log(f\"  {i}. {chat.get('name', 'No name')}\")\n\n        return unread_chats\n\n    async def _parse_search_result(\n        self, element, result_type: str = \"CHATS\"\n    ) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"\n        Parse a search result element into structured data.\n\n        Args:\n            element: ElementHandle of the search result row\n            result_type: Type of result (default: \"CHATS\")\n\n        Returns:\n            Dictionary containing parsed chat information or None if parsing fails\n\n        Note:\n            Handles two main layouts:\n            - 3 components: Group chats (group name, title, last message)\n            - 2 components: Direct chats (title, last message)\n        \"\"\"\n        try:\n            components = await element.query_selector_all(\n                \"xpath=.//div[@role='gridcell' and @aria-colindex='2']/parent::div/div\"\n            )\n            count = len(components)\n\n            # Extract unread count\n            unread_el = await element.query_selector(\n                f\"xpath={loc.SEARCH_ITEM_UNREAD_MESSAGES}\"\n            )\n            unread_count = await unread_el.inner_text() if unread_el else \"0\"\n\n            # Check for audio message\n            mic_span = await components[1].query_selector(\n                'xpath=.//span[@data-icon=\"mic\"]'\n            )\n\n            if count == 3:\n                # Group chat layout\n                span_title_0 = await components[0].query_selector(\n                    f\"xpath={loc.SPAN_TITLE}\"\n                )\n                group_title = (\n                    await span_title_0.get_attribute(\"title\") if span_title_0 else \"\"\n                )\n\n                datetime_children = await components[0].query_selector_all(\"xpath=./*\")\n                datetime_text = (\n                    await datetime_children[1].text_content()\n                    if len(datetime_children) &gt; 1\n                    else \"\"\n                )\n\n                span_title_1 = await components[1].query_selector(\n                    f\"xpath={loc.SPAN_TITLE}\"\n                )\n                title = (\n                    await span_title_1.get_attribute(\"title\") if span_title_1 else \"\"\n                )\n\n                info_text = (await components[2].text_content()) or \"\"\n                info_text = info_text.replace(\"\\n\", \"\")\n\n                # Skip invalid states\n                if any(x in info_text for x in [\"loading\", \"status-\", \"typing\"]):\n                    return None\n\n                return {\n                    \"type\": result_type,\n                    \"group\": group_title,\n                    \"name\": title,\n                    \"last_activity\": datetime_text,\n                    \"last_message\": info_text,\n                    \"last_message_type\": \"audio\" if mic_span else \"text\",\n                    \"unread_count\": unread_count,\n                    \"element\": element,\n                }\n\n            elif count == 2:\n                # Direct chat layout\n                span_title_0 = await components[0].query_selector(\n                    f\"xpath={loc.SPAN_TITLE}\"\n                )\n                title = (\n                    await span_title_0.get_attribute(\"title\") if span_title_0 else \"\"\n                )\n\n                datetime_children = await components[0].query_selector_all(\"xpath=./*\")\n                datetime_text = (\n                    await datetime_children[1].text_content()\n                    if len(datetime_children) &gt; 1\n                    else \"\"\n                )\n\n                info_children = await components[1].query_selector_all(\"xpath=./*\")\n                info_text = (\n                    await info_children[0].text_content()\n                    if len(info_children) &gt; 0\n                    else \"\"\n                ) or \"\"\n                info_text = info_text.replace(\"\\n\", \"\")\n\n                # Skip invalid states\n                if any(x in info_text for x in [\"loading\", \"status-\", \"typing\"]):\n                    return None\n\n                return {\n                    \"type\": result_type,\n                    \"name\": title,\n                    \"last_activity\": datetime_text,\n                    \"last_message\": info_text,\n                    \"last_message_type\": \"audio\" if mic_span else \"text\",\n                    \"unread_count\": unread_count,\n                    \"element\": element,\n                    \"group\": None,\n                }\n\n            return None\n\n        except Exception as e:\n            print(f\"Error parsing result: {e}\")\n            return None\n\n    async def close(self) -&gt; None:\n        \"\"\"\n        Close the current chat or view by pressing Escape.\n\n        This method safely closes any open chat window by simulating\n        the Escape key press.\n        \"\"\"\n        if self._page:\n            try:\n                await self._page.keyboard.press(\"Escape\")\n                await asyncio.sleep(0.5) # Allow UI to react\n            except Exception as e:\n                await self.client.emit(\n                    \"on_warning\", f\"Error trying to close chat with Escape: {e}\"\n                )\n\n    async def open(\n        self, chat_name: str, timeout: int = DEFAULT_WAIT_TIMEOUT, open_via_url: bool = False\n    ) -&gt; bool:\n        \"\"\"\n        Open a chat by name.\n\n        Args:\n            chat_name: Name of the chat to open\n            timeout: Maximum time to wait in milliseconds\n            open_via_url: If True, forces opening via URL (for phone numbers)\n\n        Returns:\n            True if chat was opened successfully, False otherwise\n        \"\"\"\n        return await self.wa_elements.open(chat_name, timeout, open_via_url=open_via_url)\n\n    async def search_conversations(\n        self, query: str, close: bool = True\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Search for conversations by term.\n\n        Args:\n            query: Search term\n            close: If True, closes the search after completion\n\n        Returns:\n            List of matching conversations\n        \"\"\"\n        if not await self.client.wait_until_logged_in():\n            return []\n        try:\n            return await self.wa_elements.search_chats(query, close)\n        except Exception as e:\n            await self.client.emit(\"on_error\", f\"Search error: {e}\")\n            return []\n\n    async def collect_messages(self) -&gt; List[Union[Message, FileMessage]]:\n        \"\"\"\n        Collect all currently visible messages in the active chat.\n\n        Scans all visible message containers (message-in/message-out) and\n        returns a list of Message or FileMessage instances.\n\n        Returns:\n            List of Message or FileMessage objects\n        \"\"\"\n        results: List[Union[Message, FileMessage]] = []\n        msg_elements = await self._page.query_selector_all(\n            'div[class*=\"message-in\"], div[class*=\"message-out\"]'\n        )\n\n        for elem in msg_elements:\n            # Try to parse as FileMessage first\n            file_msg = await FileMessage.from_element(elem, self._page)\n            if file_msg:\n                results.append(file_msg)\n                continue\n\n            # Fall back to regular Message\n            simple_msg = await Message.from_element(elem, self._page)\n            if simple_msg:\n                results.append(simple_msg)\n\n        return results\n\n    async def react_to_last_message(self, emoji: str) -&gt; bool:\n        \"\"\"\n        React to the last visible message in the current chat.\n\n        Args:\n            emoji: The emoji to react with (e.g., \"\ud83d\udc4d\", \"\u2764\ufe0f\")\n\n        Returns:\n            True if reaction was successful, False otherwise\n        \"\"\"\n        try:\n            messages = await self.collect_messages()\n            if not messages:\n                await self.client.emit(\"on_warning\", \"No messages found to react to.\")\n                return False\n\n            last_message = messages[-1]\n            await last_message.react(emoji)\n            return True\n        except Exception as e:\n            await self.client.emit(\"on_error\", f\"Error reacting to last message: {e}\")\n            return False\n\n    async def download_all_files(\n        self, carpeta: Optional[str] = None\n    ) -&gt; List[Path]:\n        \"\"\"\n        Download all file attachments from the current chat.\n\n        Args:\n            carpeta: Optional custom download directory path\n\n        Returns:\n            List of Path objects where files were saved\n        \"\"\"\n        if not await self.client.wait_until_logged_in():\n            return []\n\n        downloads_dir = (\n            Path(carpeta) if carpeta else DEFAULT_DOWNLOADS_DIR\n        )\n\n        saved_files: List[Path] = []\n        messages = await self.collect_messages()\n\n        for msg in messages:\n            if isinstance(msg, FileMessage):\n                file_path = await msg.download(self._page, downloads_dir)\n                if file_path:\n                    saved_files.append(file_path)\n\n        return saved_files\n\n    async def download_file_by_index(\n        self, index: int, carpeta: Optional[str] = None\n    ) -&gt; Optional[Path]:\n        \"\"\"\n        Download a specific file by its index in the message list.\n\n        Args:\n            index: Zero-based index of the file to download\n            carpeta: Optional custom download directory path\n\n        Returns:\n            Path to the downloaded file or None if failed\n        \"\"\"\n        if not await self.client.wait_until_logged_in():\n            return None\n\n        downloads_dir = (\n            Path(carpeta) if carpeta else DEFAULT_DOWNLOADS_DIR\n        )\n\n        messages = await self.collect_messages()\n        files = [m for m in messages if isinstance(m, FileMessage)]\n\n        if index &lt; 0 or index &gt;= len(files):\n            return None\n\n        return await files[index].download(self._page, downloads_dir)\n\n    async def send_message(\n        self, chat_query: str, message: str, open_via_url: bool = False\n    ) -&gt; bool:\n        \"\"\"\n        Send a text message to a chat.\n\n        Args:\n            chat_query: Name or identifier of the chat\n            message: Text message to send\n            open_via_url: If True, opens the chat via URL before sending\n\n        Returns:\n            True if message was sent successfully, False otherwise\n        \"\"\"\n        print(\"Sending message...\")\n        if not await self.client.wait_until_logged_in():\n            return False\n\n        try:\n            opened = await self.open(chat_query, open_via_url=open_via_url)\n            if not opened:\n                await self.client.emit(\n                    \"on_error\", f\"Could not open chat: {chat_query}\"\n                )\n                return False\n            print(f\"\u2713 Chat '{chat_query}' opened, sending message\")\n\n            await self._page.wait_for_selector(loc.CHAT_INPUT_BOX, timeout=DEFAULT_WAIT_TIMEOUT)\n            input_box = await self._page.wait_for_selector(\n                loc.CHAT_INPUT_BOX, timeout=DEFAULT_WAIT_TIMEOUT\n            )\n\n            if not input_box:\n                await self.client.emit(\n                    \"on_error\",\n                    \"Could not find text input box for sending message\",\n                )\n                return False\n\n            await input_box.click()\n            await input_box.fill(message)\n            await self._page.keyboard.press(\"Enter\")\n\n            # Add a short delay to allow the message to be processed by WhatsApp Web UI\n            await asyncio.sleep(2)\n\n            return True\n\n        except Exception as e:\n            await self._page.screenshot(path=\"send_message_error.png\")\n            await self.client.emit(\"on_error\", f\"Error sending message: {e}\")\n            return False\n        finally:\n            await self.close()\n\n    async def send_file(self, chat_name: str, path: str) -&gt; bool:\n        \"\"\"\n        Send a file attachment to a chat.\n\n        Args:\n            chat_name: Name of the chat to send the file to\n            path: Absolute path to the file to send\n\n        Returns:\n            True if file was sent successfully, False otherwise\n        \"\"\"\n        try:\n            if not os.path.isfile(path):\n                msg = f\"File does not exist: {path}\"\n                await self.client.emit(\"on_error\", msg)\n                return False\n\n            if not await self.client.wait_until_logged_in():\n                msg = \"Could not log in\"\n                await self.client.emit(\"on_error\", msg)\n                return False\n\n            if not await self.open(chat_name):\n                msg = f\"Could not open chat: {chat_name}\"\n                await self.client.emit(\"on_error\", msg)\n                return False\n\n            await self._page.wait_for_selector(loc.CHAT_INPUT_BOX, timeout=DEFAULT_WAIT_TIMEOUT)\n\n            attach_btn = await self._page.wait_for_selector(\n                loc.ATTACH_BUTTON, timeout=5000\n            )\n            await attach_btn.click()\n\n            input_files = await self._page.query_selector_all(loc.FILE_INPUT)\n            if not input_files:\n                msg = \"Could not find input[type='file']\"\n                await self.client.emit(\"on_error\", msg)\n                return False\n\n            await input_files[0].set_input_files(path)\n            await asyncio.sleep(1)\n\n            send_btn = await self._page.wait_for_selector(\n                loc.SEND_BUTTON, timeout=DEFAULT_WAIT_TIMEOUT\n            )\n            await send_btn.click()\n\n            return True\n\n        except Exception as e:\n            msg = f\"Unexpected error in send_file: {str(e)}\"\n            await self.client.emit(\"on_error\", msg)\n            await self._page.screenshot(path=\"send_file_error.png\")\n            return False\n        finally:\n            await self.close()\n\n    async def new_group(self, group_name: str, members: List[str]) -&gt; bool:\n        \"\"\"\n        Create a new WhatsApp group.\n\n        Args:\n            group_name: Name for the new group\n            members: List of member names to add to the group\n\n        Returns:\n            True if group was created successfully, False otherwise\n        \"\"\"\n        return await self.wa_elements.new_group(group_name, members)\n\n    async def add_members_to_group(\n        self, group_name: str, members: List[str]\n    ) -&gt; bool:\n        \"\"\"\n        Add members to an existing group.\n\n        Args:\n            group_name: Name of the group\n            members: List of member names to add\n\n        Returns:\n            True if members were added successfully, False otherwise\n        \"\"\"\n        try:\n            if not await self.open(group_name):\n                await self.client.emit(\n                    \"on_error\", f\"Could not open group '{group_name}'\"\n                )\n                return False\n\n            success = await self.wa_elements.add_members_to_group(group_name, members)\n            return success\n\n        except Exception as e:\n            await self.client.emit(\n                \"on_error\", f\"Error adding members to group '{group_name}': {e}\"\n            )\n            return False\n</code></pre>"},{"location":"api-reference/#whatsplay.chat_manager.ChatManager.__init__","title":"<code>__init__(client)</code>","text":"<p>Initialize ChatManager with client reference.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>The main WhatsApp client instance</p> required Source code in <code>src/whatsplay/chat_manager.py</code> <pre><code>def __init__(self, client: \"Client\") -&gt; None:\n    \"\"\"\n    Initialize ChatManager with client reference.\n\n    Args:\n        client: The main WhatsApp client instance\n    \"\"\"\n    self.client = client\n    self._page = client._page\n    self.wa_elements = client.wa_elements\n</code></pre>"},{"location":"api-reference/#whatsplay.chat_manager.ChatManager.add_members_to_group","title":"<code>add_members_to_group(group_name, members)</code>  <code>async</code>","text":"<p>Add members to an existing group.</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>Name of the group</p> required <code>members</code> <code>List[str]</code> <p>List of member names to add</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if members were added successfully, False otherwise</p> Source code in <code>src/whatsplay/chat_manager.py</code> <pre><code>async def add_members_to_group(\n    self, group_name: str, members: List[str]\n) -&gt; bool:\n    \"\"\"\n    Add members to an existing group.\n\n    Args:\n        group_name: Name of the group\n        members: List of member names to add\n\n    Returns:\n        True if members were added successfully, False otherwise\n    \"\"\"\n    try:\n        if not await self.open(group_name):\n            await self.client.emit(\n                \"on_error\", f\"Could not open group '{group_name}'\"\n            )\n            return False\n\n        success = await self.wa_elements.add_members_to_group(group_name, members)\n        return success\n\n    except Exception as e:\n        await self.client.emit(\n            \"on_error\", f\"Error adding members to group '{group_name}': {e}\"\n        )\n        return False\n</code></pre>"},{"location":"api-reference/#whatsplay.chat_manager.ChatManager.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close the current chat or view by pressing Escape.</p> <p>This method safely closes any open chat window by simulating the Escape key press.</p> Source code in <code>src/whatsplay/chat_manager.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"\n    Close the current chat or view by pressing Escape.\n\n    This method safely closes any open chat window by simulating\n    the Escape key press.\n    \"\"\"\n    if self._page:\n        try:\n            await self._page.keyboard.press(\"Escape\")\n            await asyncio.sleep(0.5) # Allow UI to react\n        except Exception as e:\n            await self.client.emit(\n                \"on_warning\", f\"Error trying to close chat with Escape: {e}\"\n            )\n</code></pre>"},{"location":"api-reference/#whatsplay.chat_manager.ChatManager.collect_messages","title":"<code>collect_messages()</code>  <code>async</code>","text":"<p>Collect all currently visible messages in the active chat.</p> <p>Scans all visible message containers (message-in/message-out) and returns a list of Message or FileMessage instances.</p> <p>Returns:</p> Type Description <code>List[Union[Message, FileMessage]]</code> <p>List of Message or FileMessage objects</p> Source code in <code>src/whatsplay/chat_manager.py</code> <pre><code>async def collect_messages(self) -&gt; List[Union[Message, FileMessage]]:\n    \"\"\"\n    Collect all currently visible messages in the active chat.\n\n    Scans all visible message containers (message-in/message-out) and\n    returns a list of Message or FileMessage instances.\n\n    Returns:\n        List of Message or FileMessage objects\n    \"\"\"\n    results: List[Union[Message, FileMessage]] = []\n    msg_elements = await self._page.query_selector_all(\n        'div[class*=\"message-in\"], div[class*=\"message-out\"]'\n    )\n\n    for elem in msg_elements:\n        # Try to parse as FileMessage first\n        file_msg = await FileMessage.from_element(elem, self._page)\n        if file_msg:\n            results.append(file_msg)\n            continue\n\n        # Fall back to regular Message\n        simple_msg = await Message.from_element(elem, self._page)\n        if simple_msg:\n            results.append(simple_msg)\n\n    return results\n</code></pre>"},{"location":"api-reference/#whatsplay.chat_manager.ChatManager.download_all_files","title":"<code>download_all_files(carpeta=None)</code>  <code>async</code>","text":"<p>Download all file attachments from the current chat.</p> <p>Parameters:</p> Name Type Description Default <code>carpeta</code> <code>Optional[str]</code> <p>Optional custom download directory path</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Path]</code> <p>List of Path objects where files were saved</p> Source code in <code>src/whatsplay/chat_manager.py</code> <pre><code>async def download_all_files(\n    self, carpeta: Optional[str] = None\n) -&gt; List[Path]:\n    \"\"\"\n    Download all file attachments from the current chat.\n\n    Args:\n        carpeta: Optional custom download directory path\n\n    Returns:\n        List of Path objects where files were saved\n    \"\"\"\n    if not await self.client.wait_until_logged_in():\n        return []\n\n    downloads_dir = (\n        Path(carpeta) if carpeta else DEFAULT_DOWNLOADS_DIR\n    )\n\n    saved_files: List[Path] = []\n    messages = await self.collect_messages()\n\n    for msg in messages:\n        if isinstance(msg, FileMessage):\n            file_path = await msg.download(self._page, downloads_dir)\n            if file_path:\n                saved_files.append(file_path)\n\n    return saved_files\n</code></pre>"},{"location":"api-reference/#whatsplay.chat_manager.ChatManager.download_file_by_index","title":"<code>download_file_by_index(index, carpeta=None)</code>  <code>async</code>","text":"<p>Download a specific file by its index in the message list.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Zero-based index of the file to download</p> required <code>carpeta</code> <code>Optional[str]</code> <p>Optional custom download directory path</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Path]</code> <p>Path to the downloaded file or None if failed</p> Source code in <code>src/whatsplay/chat_manager.py</code> <pre><code>async def download_file_by_index(\n    self, index: int, carpeta: Optional[str] = None\n) -&gt; Optional[Path]:\n    \"\"\"\n    Download a specific file by its index in the message list.\n\n    Args:\n        index: Zero-based index of the file to download\n        carpeta: Optional custom download directory path\n\n    Returns:\n        Path to the downloaded file or None if failed\n    \"\"\"\n    if not await self.client.wait_until_logged_in():\n        return None\n\n    downloads_dir = (\n        Path(carpeta) if carpeta else DEFAULT_DOWNLOADS_DIR\n    )\n\n    messages = await self.collect_messages()\n    files = [m for m in messages if isinstance(m, FileMessage)]\n\n    if index &lt; 0 or index &gt;= len(files):\n        return None\n\n    return await files[index].download(self._page, downloads_dir)\n</code></pre>"},{"location":"api-reference/#whatsplay.chat_manager.ChatManager.new_group","title":"<code>new_group(group_name, members)</code>  <code>async</code>","text":"<p>Create a new WhatsApp group.</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>Name for the new group</p> required <code>members</code> <code>List[str]</code> <p>List of member names to add to the group</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if group was created successfully, False otherwise</p> Source code in <code>src/whatsplay/chat_manager.py</code> <pre><code>async def new_group(self, group_name: str, members: List[str]) -&gt; bool:\n    \"\"\"\n    Create a new WhatsApp group.\n\n    Args:\n        group_name: Name for the new group\n        members: List of member names to add to the group\n\n    Returns:\n        True if group was created successfully, False otherwise\n    \"\"\"\n    return await self.wa_elements.new_group(group_name, members)\n</code></pre>"},{"location":"api-reference/#whatsplay.chat_manager.ChatManager.open","title":"<code>open(chat_name, timeout=DEFAULT_WAIT_TIMEOUT, open_via_url=False)</code>  <code>async</code>","text":"<p>Open a chat by name.</p> <p>Parameters:</p> Name Type Description Default <code>chat_name</code> <code>str</code> <p>Name of the chat to open</p> required <code>timeout</code> <code>int</code> <p>Maximum time to wait in milliseconds</p> <code>DEFAULT_WAIT_TIMEOUT</code> <code>open_via_url</code> <code>bool</code> <p>If True, forces opening via URL (for phone numbers)</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if chat was opened successfully, False otherwise</p> Source code in <code>src/whatsplay/chat_manager.py</code> <pre><code>async def open(\n    self, chat_name: str, timeout: int = DEFAULT_WAIT_TIMEOUT, open_via_url: bool = False\n) -&gt; bool:\n    \"\"\"\n    Open a chat by name.\n\n    Args:\n        chat_name: Name of the chat to open\n        timeout: Maximum time to wait in milliseconds\n        open_via_url: If True, forces opening via URL (for phone numbers)\n\n    Returns:\n        True if chat was opened successfully, False otherwise\n    \"\"\"\n    return await self.wa_elements.open(chat_name, timeout, open_via_url=open_via_url)\n</code></pre>"},{"location":"api-reference/#whatsplay.chat_manager.ChatManager.react_to_last_message","title":"<code>react_to_last_message(emoji)</code>  <code>async</code>","text":"<p>React to the last visible message in the current chat.</p> <p>Parameters:</p> Name Type Description Default <code>emoji</code> <code>str</code> <p>The emoji to react with (e.g., \"\ud83d\udc4d\", \"\u2764\ufe0f\")</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if reaction was successful, False otherwise</p> Source code in <code>src/whatsplay/chat_manager.py</code> <pre><code>async def react_to_last_message(self, emoji: str) -&gt; bool:\n    \"\"\"\n    React to the last visible message in the current chat.\n\n    Args:\n        emoji: The emoji to react with (e.g., \"\ud83d\udc4d\", \"\u2764\ufe0f\")\n\n    Returns:\n        True if reaction was successful, False otherwise\n    \"\"\"\n    try:\n        messages = await self.collect_messages()\n        if not messages:\n            await self.client.emit(\"on_warning\", \"No messages found to react to.\")\n            return False\n\n        last_message = messages[-1]\n        await last_message.react(emoji)\n        return True\n    except Exception as e:\n        await self.client.emit(\"on_error\", f\"Error reacting to last message: {e}\")\n        return False\n</code></pre>"},{"location":"api-reference/#whatsplay.chat_manager.ChatManager.search_conversations","title":"<code>search_conversations(query, close=True)</code>  <code>async</code>","text":"<p>Search for conversations by term.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Search term</p> required <code>close</code> <code>bool</code> <p>If True, closes the search after completion</p> <code>True</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of matching conversations</p> Source code in <code>src/whatsplay/chat_manager.py</code> <pre><code>async def search_conversations(\n    self, query: str, close: bool = True\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Search for conversations by term.\n\n    Args:\n        query: Search term\n        close: If True, closes the search after completion\n\n    Returns:\n        List of matching conversations\n    \"\"\"\n    if not await self.client.wait_until_logged_in():\n        return []\n    try:\n        return await self.wa_elements.search_chats(query, close)\n    except Exception as e:\n        await self.client.emit(\"on_error\", f\"Search error: {e}\")\n        return []\n</code></pre>"},{"location":"api-reference/#whatsplay.chat_manager.ChatManager.send_file","title":"<code>send_file(chat_name, path)</code>  <code>async</code>","text":"<p>Send a file attachment to a chat.</p> <p>Parameters:</p> Name Type Description Default <code>chat_name</code> <code>str</code> <p>Name of the chat to send the file to</p> required <code>path</code> <code>str</code> <p>Absolute path to the file to send</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if file was sent successfully, False otherwise</p> Source code in <code>src/whatsplay/chat_manager.py</code> <pre><code>async def send_file(self, chat_name: str, path: str) -&gt; bool:\n    \"\"\"\n    Send a file attachment to a chat.\n\n    Args:\n        chat_name: Name of the chat to send the file to\n        path: Absolute path to the file to send\n\n    Returns:\n        True if file was sent successfully, False otherwise\n    \"\"\"\n    try:\n        if not os.path.isfile(path):\n            msg = f\"File does not exist: {path}\"\n            await self.client.emit(\"on_error\", msg)\n            return False\n\n        if not await self.client.wait_until_logged_in():\n            msg = \"Could not log in\"\n            await self.client.emit(\"on_error\", msg)\n            return False\n\n        if not await self.open(chat_name):\n            msg = f\"Could not open chat: {chat_name}\"\n            await self.client.emit(\"on_error\", msg)\n            return False\n\n        await self._page.wait_for_selector(loc.CHAT_INPUT_BOX, timeout=DEFAULT_WAIT_TIMEOUT)\n\n        attach_btn = await self._page.wait_for_selector(\n            loc.ATTACH_BUTTON, timeout=5000\n        )\n        await attach_btn.click()\n\n        input_files = await self._page.query_selector_all(loc.FILE_INPUT)\n        if not input_files:\n            msg = \"Could not find input[type='file']\"\n            await self.client.emit(\"on_error\", msg)\n            return False\n\n        await input_files[0].set_input_files(path)\n        await asyncio.sleep(1)\n\n        send_btn = await self._page.wait_for_selector(\n            loc.SEND_BUTTON, timeout=DEFAULT_WAIT_TIMEOUT\n        )\n        await send_btn.click()\n\n        return True\n\n    except Exception as e:\n        msg = f\"Unexpected error in send_file: {str(e)}\"\n        await self.client.emit(\"on_error\", msg)\n        await self._page.screenshot(path=\"send_file_error.png\")\n        return False\n    finally:\n        await self.close()\n</code></pre>"},{"location":"api-reference/#whatsplay.chat_manager.ChatManager.send_message","title":"<code>send_message(chat_query, message, open_via_url=False)</code>  <code>async</code>","text":"<p>Send a text message to a chat.</p> <p>Parameters:</p> Name Type Description Default <code>chat_query</code> <code>str</code> <p>Name or identifier of the chat</p> required <code>message</code> <code>str</code> <p>Text message to send</p> required <code>open_via_url</code> <code>bool</code> <p>If True, opens the chat via URL before sending</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if message was sent successfully, False otherwise</p> Source code in <code>src/whatsplay/chat_manager.py</code> <pre><code>async def send_message(\n    self, chat_query: str, message: str, open_via_url: bool = False\n) -&gt; bool:\n    \"\"\"\n    Send a text message to a chat.\n\n    Args:\n        chat_query: Name or identifier of the chat\n        message: Text message to send\n        open_via_url: If True, opens the chat via URL before sending\n\n    Returns:\n        True if message was sent successfully, False otherwise\n    \"\"\"\n    print(\"Sending message...\")\n    if not await self.client.wait_until_logged_in():\n        return False\n\n    try:\n        opened = await self.open(chat_query, open_via_url=open_via_url)\n        if not opened:\n            await self.client.emit(\n                \"on_error\", f\"Could not open chat: {chat_query}\"\n            )\n            return False\n        print(f\"\u2713 Chat '{chat_query}' opened, sending message\")\n\n        await self._page.wait_for_selector(loc.CHAT_INPUT_BOX, timeout=DEFAULT_WAIT_TIMEOUT)\n        input_box = await self._page.wait_for_selector(\n            loc.CHAT_INPUT_BOX, timeout=DEFAULT_WAIT_TIMEOUT\n        )\n\n        if not input_box:\n            await self.client.emit(\n                \"on_error\",\n                \"Could not find text input box for sending message\",\n            )\n            return False\n\n        await input_box.click()\n        await input_box.fill(message)\n        await self._page.keyboard.press(\"Enter\")\n\n        # Add a short delay to allow the message to be processed by WhatsApp Web UI\n        await asyncio.sleep(2)\n\n        return True\n\n    except Exception as e:\n        await self._page.screenshot(path=\"send_message_error.png\")\n        await self.client.emit(\"on_error\", f\"Error sending message: {e}\")\n        return False\n    finally:\n        await self.close()\n</code></pre>"},{"location":"api-reference/#state-manager","title":"State Manager","text":"<p>Responsible for managing the client's internal state.</p>"},{"location":"api-reference/#whatsplay.state_manager.StateManager","title":"<code>whatsplay.state_manager.StateManager</code>","text":"<p>Manages WhatsApp Web client state transitions and QR code handling.</p> <p>This class monitors the WhatsApp Web state and triggers appropriate actions for each state transition, including QR code display, authentication handling, and unread message detection.</p> <p>Attributes:</p> Name Type Description <code>client</code> <p>Reference to the main WhatsApp client</p> <code>_page</code> <p>Playwright page object for browser interactions</p> <code>wa_elements</code> <p>WhatsApp Web elements helper</p> <code>last_qr_shown</code> <code>Optional[bytes]</code> <p>Binary data of the last displayed QR code</p> <code>qr_server_started</code> <code>bool</code> <p>Flag indicating if QR server is running</p> Source code in <code>src/whatsplay/state_manager.py</code> <pre><code>class StateManager:\n    \"\"\"\n    Manages WhatsApp Web client state transitions and QR code handling.\n\n    This class monitors the WhatsApp Web state and triggers appropriate\n    actions for each state transition, including QR code display,\n    authentication handling, and unread message detection.\n\n    Attributes:\n        client: Reference to the main WhatsApp client\n        _page: Playwright page object for browser interactions\n        wa_elements: WhatsApp Web elements helper\n        last_qr_shown: Binary data of the last displayed QR code\n        qr_server_started: Flag indicating if QR server is running\n    \"\"\"\n\n    def __init__(self, client: \"Client\") -&gt; None:\n        \"\"\"\n        Initialize StateManager with client reference.\n\n        Args:\n            client: The main WhatsApp client instance\n        \"\"\"\n        self.client = client\n        self._page = client._page\n        self.wa_elements = client.wa_elements\n        self.last_qr_shown: Optional[bytes] = None\n        self.qr_server_started: bool = False\n\n    async def _get_state(self) -&gt; Optional[State]:\n        \"\"\"\n        Get the current state of WhatsApp Web.\n\n        Returns:\n            Current State enum value or None if state cannot be determined\n        \"\"\"\n        return await self.wa_elements.get_state()\n\n    async def _handle_qr_logic(self, qr_binary: bytes) -&gt; bool:\n        \"\"\"\n        Handle the logic for showing and updating the QR code.\n\n        This method manages the QR code server lifecycle and updates\n        the displayed QR code when it changes.\n\n        Args:\n            qr_binary: Binary data of the QR code image\n\n        Returns:\n            True if QR code was updated or shown, False otherwise\n        \"\"\"\n        if not qr_binary or qr_binary == self.last_qr_shown:\n            return False\n\n        if not self.qr_server_started:\n            show_qr_window(qr_binary)\n            self.qr_server_started = True\n        else:\n            update_qr_code(qr_binary)\n\n        self.last_qr_shown = qr_binary\n        return True\n\n    async def _handle_state_change(\n        self, curr_state: State, prev_state: Optional[State]\n    ) -&gt; None:\n        \"\"\"\n        Handle state transitions.\n\n        This method is called when the WhatsApp Web state changes and\n        triggers appropriate actions for each state.\n\n        Args:\n            curr_state: Current state\n            prev_state: Previous state (may be None on first detection)\n        \"\"\"\n        if curr_state == State.AUTH:\n            await self._handle_auth_state()\n\n        elif curr_state == State.QR_AUTH:\n            await self._handle_qr_auth_state_change()\n\n        elif curr_state == State.LOADING:\n            await self._handle_loading_state()\n\n        elif curr_state == State.LOGGED_IN:\n            await self._handle_logged_in_state_change()\n\n    async def _handle_auth_state(self) -&gt; None:\n        \"\"\"Handle the authentication state.\"\"\"\n        await self.client.emit(\"on_auth\")\n\n    async def _handle_qr_auth_state_change(self) -&gt; None:\n        \"\"\"Handle QR authentication state transition.\"\"\"\n        try:\n            qr_code_canvas = await self._page.wait_for_selector(\n                loc.QR_CODE, timeout=QR_CODE_TIMEOUT\n            )\n            qr_binary = await self._extract_image_from_canvas(qr_code_canvas)\n\n            if await self._handle_qr_logic(qr_binary):\n                await self.client.emit(\"on_qr\", qr_binary)\n\n        except PlaywrightTimeoutError:\n            await self.client.emit(\n                \"on_warning\", \"Timeout waiting for QR code\"\n            )\n        except Exception as e:\n            await self.client.emit(\"on_error\", f\"Error processing QR code: {e}\")\n\n    async def _handle_loading_state(self) -&gt; None:\n        \"\"\"Handle the loading state.\"\"\"\n        loading_chats = (\n            await self.wa_elements.wait_for_selector(loc.LOADING_CHATS) is not None\n        )\n        await self.client.emit(\"on_loading\", loading_chats)\n\n    async def _handle_logged_in_state_change(self) -&gt; None:\n        \"\"\"Handle logged-in state transition.\"\"\"\n        if self.qr_server_started:\n            close_qr_window()\n            self.qr_server_started = False\n\n        await self.client.emit(\"on_logged_in\")\n        await self._handle_logged_in_state()\n\n    async def _handle_same_state(self, state: State) -&gt; None:\n        \"\"\"\n        Handle logic when the state hasn't changed.\n\n        This method is called on each tick when the state remains the same,\n        allowing for periodic actions like QR code refresh or unread message checks.\n\n        Args:\n            state: Current state\n        \"\"\"\n        if state == State.QR_AUTH:\n            await self._handle_qr_auth_state()\n        elif state == State.LOGGED_IN:\n            await self._handle_logged_in_state()\n\n    async def _handle_qr_auth_state(self) -&gt; None:\n        \"\"\"\n        Handle QR authentication state (periodic check).\n\n        Checks if the QR code has changed and updates the display if necessary.\n        \"\"\"\n        try:\n            qr_code_canvas = await self._page.query_selector(loc.QR_CODE)\n            if not qr_code_canvas:\n                return\n\n            curr_qr_binary = await self._extract_image_from_canvas(qr_code_canvas)\n\n            if await self._handle_qr_logic(curr_qr_binary):\n                await self.client.emit(\"on_qr_change\", curr_qr_binary)\n\n        except Exception as e:\n            await self.client.emit(\"on_warning\", f\"Error updating QR code: {e}\")\n\n    async def _handle_logged_in_state(self) -&gt; None:\n        \"\"\"\n        Handle logged-in state (periodic check).\n\n        Checks for continue buttons and unread chats when in logged-in state.\n        \"\"\"\n        try:\n            # Check for continue button (privacy policy updates, etc.)\n            continue_button = await self._page.query_selector(\n                \"button:has(div:has-text('Continue'))\"\n            )\n            if continue_button:\n                await continue_button.click()\n                await asyncio.sleep(DEFAULT_SLEEP_AFTER_CONTINUE)\n                return\n\n            # Check for unread chats\n            unread_chats = await self.client.chat_manager._check_unread_chats()\n            if unread_chats:\n                await self.client.emit(\"on_unread_chat\", unread_chats)\n\n        except Exception as e:\n            await self.client.emit(\"on_error\", f\"Error in logged-in state: {e}\")\n\n    async def _extract_image_from_canvas(\n        self, canvas_element: Optional[ElementHandle]\n    ) -&gt; Optional[bytes]:\n        \"\"\"\n        Extract image data from a canvas element.\n\n        Args:\n            canvas_element: Canvas element containing the image\n\n        Returns:\n            Binary image data or None if extraction fails\n        \"\"\"\n        if not canvas_element:\n            return None\n\n        try:\n            return await canvas_element.screenshot()\n        except Exception as e:\n            await self.client.emit(\"on_error\", f\"Error extracting QR image: {e}\")\n            return None\n</code></pre>"},{"location":"api-reference/#whatsplay.state_manager.StateManager.__init__","title":"<code>__init__(client)</code>","text":"<p>Initialize StateManager with client reference.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>The main WhatsApp client instance</p> required Source code in <code>src/whatsplay/state_manager.py</code> <pre><code>def __init__(self, client: \"Client\") -&gt; None:\n    \"\"\"\n    Initialize StateManager with client reference.\n\n    Args:\n        client: The main WhatsApp client instance\n    \"\"\"\n    self.client = client\n    self._page = client._page\n    self.wa_elements = client.wa_elements\n    self.last_qr_shown: Optional[bytes] = None\n    self.qr_server_started: bool = False\n</code></pre>"},{"location":"api-reference/#authentication","title":"Authentication","text":"<p>Authentication handlers are used to manage the WhatsApp session.</p>"},{"location":"api-reference/#local-profile-auth","title":"Local Profile Auth","text":"<p>The recommended handler for saving your session locally to avoid repeated QR scans.</p>"},{"location":"api-reference/#whatsplay.auth.local_profile_auth.LocalProfileAuth","title":"<code>whatsplay.auth.local_profile_auth.LocalProfileAuth</code>","text":"<p>               Bases: <code>AuthBase</code></p> <p>Authentication using a local browser profile</p> Source code in <code>src/whatsplay/auth/local_profile_auth.py</code> <pre><code>class LocalProfileAuth(AuthBase):\n    \"\"\"Authentication using a local browser profile\"\"\"\n\n    def __init__(self, data_dir: str, profile: str = \"Default\"):\n        super().__init__()\n        self.data_dir = os.path.abspath(data_dir)\n        self.profile = profile\n        self.profile_path = os.path.join(self.data_dir, self.profile)\n        os.makedirs(self.profile_path, exist_ok=True)\n\n    def get_browser_args(self) -&gt; Dict[str, Any]:\n        \"\"\"Get browser launch arguments for profile\"\"\"\n        return {\n            \"headless\": False,  # Profile persistence doesn't work well in headless mode\n            \"args\": [\n                \"--no-sandbox\",\n                \"--disable-setuid-sandbox\",\n                \"--disable-dev-shm-usage\",\n            ],\n        }\n\n    async def setup_context(self, context: BrowserContext) -&gt; None:\n        \"\"\"Configure browser context with profile settings\"\"\"\n        await context.storage_state(path=os.path.join(self.profile_path, \"state.json\"))\n\n    async def save_session(self) -&gt; bool:\n        \"\"\"Save browser session state\"\"\"\n        try:\n            os.makedirs(self.profile_path, exist_ok=True)\n            return True\n        except Exception as e:\n            print(f\"Error saving session: {e}\")\n            return False\n\n    async def load_session(self) -&gt; bool:\n        \"\"\"Check if profile exists and has state\"\"\"\n        state_file = os.path.join(self.profile_path, \"state.json\")\n        return os.path.exists(self.profile_path) and os.path.exists(state_file)\n</code></pre>"},{"location":"api-reference/#whatsplay.auth.local_profile_auth.LocalProfileAuth.get_browser_args","title":"<code>get_browser_args()</code>","text":"<p>Get browser launch arguments for profile</p> Source code in <code>src/whatsplay/auth/local_profile_auth.py</code> <pre><code>def get_browser_args(self) -&gt; Dict[str, Any]:\n    \"\"\"Get browser launch arguments for profile\"\"\"\n    return {\n        \"headless\": False,  # Profile persistence doesn't work well in headless mode\n        \"args\": [\n            \"--no-sandbox\",\n            \"--disable-setuid-sandbox\",\n            \"--disable-dev-shm-usage\",\n        ],\n    }\n</code></pre>"},{"location":"api-reference/#whatsplay.auth.local_profile_auth.LocalProfileAuth.load_session","title":"<code>load_session()</code>  <code>async</code>","text":"<p>Check if profile exists and has state</p> Source code in <code>src/whatsplay/auth/local_profile_auth.py</code> <pre><code>async def load_session(self) -&gt; bool:\n    \"\"\"Check if profile exists and has state\"\"\"\n    state_file = os.path.join(self.profile_path, \"state.json\")\n    return os.path.exists(self.profile_path) and os.path.exists(state_file)\n</code></pre>"},{"location":"api-reference/#whatsplay.auth.local_profile_auth.LocalProfileAuth.save_session","title":"<code>save_session()</code>  <code>async</code>","text":"<p>Save browser session state</p> Source code in <code>src/whatsplay/auth/local_profile_auth.py</code> <pre><code>async def save_session(self) -&gt; bool:\n    \"\"\"Save browser session state\"\"\"\n    try:\n        os.makedirs(self.profile_path, exist_ok=True)\n        return True\n    except Exception as e:\n        print(f\"Error saving session: {e}\")\n        return False\n</code></pre>"},{"location":"api-reference/#whatsplay.auth.local_profile_auth.LocalProfileAuth.setup_context","title":"<code>setup_context(context)</code>  <code>async</code>","text":"<p>Configure browser context with profile settings</p> Source code in <code>src/whatsplay/auth/local_profile_auth.py</code> <pre><code>async def setup_context(self, context: BrowserContext) -&gt; None:\n    \"\"\"Configure browser context with profile settings\"\"\"\n    await context.storage_state(path=os.path.join(self.profile_path, \"state.json\"))\n</code></pre>"},{"location":"api-reference/#no-auth","title":"No Auth","text":"<p>A handler that does not save any session data, requiring a new login on every run.</p>"},{"location":"api-reference/#whatsplay.auth.no_auth.NoAuth","title":"<code>whatsplay.auth.no_auth.NoAuth</code>","text":"<p>               Bases: <code>AuthBase</code></p> <p>Authentication strategy that doesn't persist any data</p> Source code in <code>src/whatsplay/auth/no_auth.py</code> <pre><code>class NoAuth(AuthBase):\n    \"\"\"Authentication strategy that doesn't persist any data\"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n    def get_browser_args(self) -&gt; Dict[str, Any]:\n        \"\"\"Get browser launch arguments\"\"\"\n        return {\"headless\": False}\n\n    async def setup_context(self, context: BrowserContext) -&gt; None:\n        \"\"\"No special configuration needed\"\"\"\n        pass\n\n    async def save_session(self) -&gt; bool:\n        \"\"\"No session to save\"\"\"\n        return False\n\n    async def load_session(self) -&gt; bool:\n        \"\"\"No session to load\"\"\"\n        return False\n</code></pre>"},{"location":"api-reference/#whatsplay.auth.no_auth.NoAuth.get_browser_args","title":"<code>get_browser_args()</code>","text":"<p>Get browser launch arguments</p> Source code in <code>src/whatsplay/auth/no_auth.py</code> <pre><code>def get_browser_args(self) -&gt; Dict[str, Any]:\n    \"\"\"Get browser launch arguments\"\"\"\n    return {\"headless\": False}\n</code></pre>"},{"location":"api-reference/#whatsplay.auth.no_auth.NoAuth.load_session","title":"<code>load_session()</code>  <code>async</code>","text":"<p>No session to load</p> Source code in <code>src/whatsplay/auth/no_auth.py</code> <pre><code>async def load_session(self) -&gt; bool:\n    \"\"\"No session to load\"\"\"\n    return False\n</code></pre>"},{"location":"api-reference/#whatsplay.auth.no_auth.NoAuth.save_session","title":"<code>save_session()</code>  <code>async</code>","text":"<p>No session to save</p> Source code in <code>src/whatsplay/auth/no_auth.py</code> <pre><code>async def save_session(self) -&gt; bool:\n    \"\"\"No session to save\"\"\"\n    return False\n</code></pre>"},{"location":"api-reference/#whatsplay.auth.no_auth.NoAuth.setup_context","title":"<code>setup_context(context)</code>  <code>async</code>","text":"<p>No special configuration needed</p> Source code in <code>src/whatsplay/auth/no_auth.py</code> <pre><code>async def setup_context(self, context: BrowserContext) -&gt; None:\n    \"\"\"No special configuration needed\"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/#filters","title":"Filters","text":"<p>The <code>filters</code> module provides classes and instances to filter events.</p>"},{"location":"api-reference/#predefined-message-filters","title":"Predefined Message Filters","text":"<p>A collection of ready-to-use filters for the <code>on_message</code> event.</p>"},{"location":"api-reference/#whatsplay.filters.message_filter","title":"<code>whatsplay.filters.message_filter</code>","text":"<p>Message filtering utilities for WhatsApp messages</p>"},{"location":"api-reference/#whatsplay.filters.message_filter.MessageFilter","title":"<code>MessageFilter</code>","text":"<p>Helper class for filtering WhatsApp messages</p> Source code in <code>src/whatsplay/filters/message_filter.py</code> <pre><code>class MessageFilter:\n    \"\"\"Helper class for filtering WhatsApp messages\"\"\"\n\n    @classmethod\n    def filter_search_result(cls, text: str) -&gt; list[str]:\n        \"\"\"Filtra y formatea un resultado de b\u00fasqueda\n\n        Returns:\n            List[str]: (texto_formateado)\n        \"\"\"\n        text = text.strip()\n\n        # Formatear el resultado\n        lines = text.split(\"\\n\")\n        if len(lines) &gt;= 2:\n            name = lines[0].strip()\n            date = lines[1].strip()\n            message = \" \".join(lines[2:]).strip() if len(lines) &gt; 2 else \"\"\n\n            # No mostrar si el mensaje est\u00e1 vac\u00edo o muy corto\n            if not message or len(message) &lt; 2:\n                return text\n\n            # No mostrar si el mensaje solo contiene n\u00fameros o caracteres especiales\n            if all(c.isdigit() or c in \".,-_+=/\\\\\" for c in message.replace(\" \", \"\")):\n                return text\n\n            text_formatted = {\"name\": name, \"date\": date, \"message\": message}\n            return text_formatted\n\n        return text\n</code></pre>"},{"location":"api-reference/#whatsplay.filters.message_filter.MessageFilter.filter_search_result","title":"<code>filter_search_result(text)</code>  <code>classmethod</code>","text":"<p>Filtra y formatea un resultado de b\u00fasqueda</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List[str]: (texto_formateado)</p> Source code in <code>src/whatsplay/filters/message_filter.py</code> <pre><code>@classmethod\ndef filter_search_result(cls, text: str) -&gt; list[str]:\n    \"\"\"Filtra y formatea un resultado de b\u00fasqueda\n\n    Returns:\n        List[str]: (texto_formateado)\n    \"\"\"\n    text = text.strip()\n\n    # Formatear el resultado\n    lines = text.split(\"\\n\")\n    if len(lines) &gt;= 2:\n        name = lines[0].strip()\n        date = lines[1].strip()\n        message = \" \".join(lines[2:]).strip() if len(lines) &gt; 2 else \"\"\n\n        # No mostrar si el mensaje est\u00e1 vac\u00edo o muy corto\n        if not message or len(message) &lt; 2:\n            return text\n\n        # No mostrar si el mensaje solo contiene n\u00fameros o caracteres especiales\n        if all(c.isdigit() or c in \".,-_+=/\\\\\" for c in message.replace(\" \", \"\")):\n            return text\n\n        text_formatted = {\"name\": name, \"date\": date, \"message\": message}\n        return text_formatted\n\n    return text\n</code></pre>"},{"location":"api-reference/#custom-filter-base-class","title":"Custom Filter Base Class","text":"<p>Inherit from this class to create your own powerful, reusable filters.</p>"},{"location":"api-reference/#whatsplay.filters.filters.CustomFilter","title":"<code>whatsplay.filters.filters.CustomFilter</code>","text":"<p>               Bases: <code>Filter</code></p> <p>A filter that uses a custom function to test values.</p> Source code in <code>src/whatsplay/filters/filters.py</code> <pre><code>class CustomFilter(Filter):\n    \"\"\"\n    A filter that uses a custom function to test values.\n    \"\"\"\n\n    def __init__(self, func: Callable[[Any], bool]):\n        self.func = func\n\n    def test(self, value: Any) -&gt; bool:\n        return self.func(value)\n</code></pre>"},{"location":"getting-started/","title":"Getting Started with WhatsPlay","text":"<p>This guide will walk you through installing WhatsPlay and writing your first script to send a WhatsApp message.</p>"},{"location":"getting-started/#1-installation","title":"1. Installation","text":"<p>WhatsPlay requires Python 3.8 or newer. You can install it directly from PyPI. We also recommend installing Playwright's browser dependencies.</p> <p>First, install the library:</p> <pre><code>pip install whatsplay\n</code></pre> <p>Next, install the necessary browser binaries for Playwright (this will download a browser like Chromium):</p> <pre><code>playwright install\n</code></pre>"},{"location":"getting-started/#2-your-first-script-sending-a-message","title":"2. Your First Script: Sending a Message","text":"<p>Let's create a simple script that logs into WhatsApp and sends a message.</p> <p>Create a new Python file, for example <code>send_hello.py</code>, and add the following code.</p> <pre><code>import asyncio\nfrom whatsplay import Client\nfrom whatsplay.auth import LocalProfileAuth\n\nasync def main():\n    \"\"\"\n    Main function to initialize the client, send a message, and stop.\n    \"\"\"\n\n    # --- Step 1: Set up Authentication ---\n    # This tells WhatsPlay to save session data in a folder named \"whatsapp_session\".\n    # This way, you only need to scan the QR code once.\n    auth = LocalProfileAuth(user_data_dir=\"./whatsapp_session\")\n\n    # --- Step 2: Initialize the Client ---\n    # We run in headless=False for the first time to make it easy to scan the QR code.\n    # You can set it to headless=True later for background execution.\n    client = Client(auth=auth, headless=False)\n\n    # --- Step 3: Define Event Handlers ---\n    # `on_start` is triggered once the client is logged in and ready.\n    @client.event(\"on_start\")\n    async def on_start():\n        print(\"Client is ready! Preparing to send a message...\")\n\n        # Define your recipient and message\n        # IMPORTANT: Replace with a real phone number or contact name.\n        # For phone numbers, use the format with country code but no '+' or '00'.\n        recipient = \"1234567890\" \n        message = \"This is my first message from WhatsPlay! \ud83c\udf89\"\n\n        # Send the message\n        success = await client.send_message(recipient, message)\n\n        if success:\n            print(f\"Message sent successfully to {recipient}!\")\n        else:\n            print(f\"Oops! Failed to send message to {recipient}.\")\n\n        # Stop the client after the job is done\n        print(\"Work complete. Shutting down...\")\n        await client.stop()\n\n    # `on_qr` is triggered if a QR scan is needed.\n    @client.event(\"on_qr\")\n    async def on_qr(qr):\n        print(\"Login required. A browser window should open for you to scan the QR code.\")\n\n    # `on_auth` is triggered if authentication is required\n    @client.event(\"on_auth\")\n    async def on_auth():\n        print(\"Authentication is required.\")\n\n    # `on_error` catches potential errors during execution\n    @client.event(\"on_error\")\n    async def on_error(error):\n        print(f\"An error occurred: {error}\")\n        await client.stop()\n\n    # --- Step 4: Start the Client ---\n    # This call starts the browser and begins the login process.\n    await client.start()\n    print(\"Script has finished executing.\")\n\n# --- Run the main function ---\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"getting-started/#how-to-run-it","title":"How to Run It","text":"<ol> <li>Save the code: Save the script as <code>send_hello.py</code>.</li> <li>Modify the recipient: Change <code>\"1234567890\"</code> to a real phone number or a contact name saved in your WhatsApp.</li> <li>Execute from your terminal: <pre><code>python send_hello.py\n</code></pre></li> <li>First-time Login: A browser window will open. Scan the WhatsApp Web QR code with your phone.</li> <li>Subsequent Runs: The script will reuse the session and should log in automatically. The message will be sent, and the script will exit.</li> </ol>"},{"location":"guides/advanced-features/","title":"Guide: Advanced Features","text":"<p>Beyond sending and receiving messages, WhatsPlay offers several advanced features to help you manage your chats and interact more naturally.</p>"},{"location":"guides/advanced-features/#searching-for-conversations","title":"Searching for Conversations","text":"<p>If you have a long list of chats, you can use the search function to find specific contacts or groups.</p> <pre><code># Search for a contact or group\n# Returns a list of matching results\nresults = await client.search_conversations(\"Project Alpha\")\n\nfor result in results:\n    print(f\"Found: {result['name']}\")\n    # You can then open it using the exact name\n    await client.open(result['name'])\n</code></pre>"},{"location":"guides/advanced-features/#reacting-to-messages","title":"Reacting to Messages","text":"<p>You can react to the last received message in a chat using emojis. This is great for acknowledging receipt without sending a full text message.</p> <pre><code>await client.open(\"My Friend\")\n\n# React with a thumbs up\nsuccess = await client.react_to_last_message(\"\ud83d\udc4d\")\n\nif success:\n    print(\"Reacted successfully!\")\n</code></pre>"},{"location":"guides/advanced-features/#downloading-all-files","title":"Downloading All Files","text":"<p>If you need to archive media or documents from a chat, <code>download_all_files</code> allows you to grab every visible attachment in the current view.</p> <pre><code>await client.open(\"Family Group\")\n\n# Download all visible files to a specific folder\nsaved_paths = await client.download_all_files(carpeta=\"./downloads/family_photos\")\n\nprint(f\"Downloaded {len(saved_paths)} files.\")\n</code></pre>"},{"location":"guides/advanced-features/#scraping-chat-history","title":"Scraping Chat History","text":"<p>You can combine <code>open</code> and <code>collect_messages</code> to scrape chat history. Note that WhatsPlay currently interacts with the visible DOM, so you may need to implement scrolling logic if you need to fetch very old messages (though basic scrolling is handled by the browser interaction).</p> <pre><code>await client.open(\"Work Chat\")\n\n# Get all currently loaded messages\nmessages = await client.collect_messages()\n\nfor msg in messages:\n    print(f\"[{msg.timestamp}] {msg.sender.name}: {msg.text}\")\n</code></pre>"},{"location":"guides/group-management/","title":"Guide: Group Management","text":"<p>WhatsPlay provides robust functionality for managing WhatsApp groups, allowing you to create new groups and manage their members programmatically.</p>"},{"location":"guides/group-management/#creating-a-new-group","title":"Creating a New Group","text":"<p>You can create a new WhatsApp group by using the <code>client.new_group()</code> method. This method requires a group name and a list of contact names or phone numbers for the initial members.</p> <p>Important: The contacts in the <code>members</code> list must already be in your WhatsApp contacts or be valid phone numbers (including country code, without '+' or '00').</p> <pre><code>import asyncio\nfrom whatsplay import Client\nfrom whatsplay.auth import LocalProfileAuth\n\nasync def create_my_group():\n    auth = LocalProfileAuth(user_data_dir=\"./whatsapp_session\")\n    client = Client(auth=auth, headless=True) # Set headless=False if you want to see the browser\n\n    @client.event(\"on_start\")\n    async def on_start():\n        print(\"Client ready. Attempting to create a new group...\")\n\n        group_name = \"My Awesome WhatsPlay Group\"\n        # Use existing contact names or phone numbers\n        initial_members = [\"Contact Name 1\", \"5491123456789\"] # Example: \"54911...\" for Argentina mobile\n\n        success = await client.new_group(group_name, initial_members)\n\n        if success:\n            print(f\"Group '{group_name}' created successfully with initial members.\")\n        else:\n            print(f\"Failed to create group '{group_name}'.\")\n\n        await client.stop()\n\n    @client.event(\"on_qr\")\n    async def on_qr(qr):\n        print(\"Please scan the QR code to log in.\")\n\n    await client.start()\n\nif __name__ == \"__main__\":\n    asyncio.run(create_my_group())\n</code></pre>"},{"location":"guides/group-management/#adding-members-to-an-existing-group","title":"Adding Members to an Existing Group","text":"<p>To add more members to an already existing group, use the <code>client.add_members_to_group()</code> method. You need to provide the name of the group and a list of members to add.</p> <pre><code>import asyncio\nfrom whatsplay import Client\nfrom whatsplay.auth import LocalProfileAuth\n\nasync def add_members_to_existing_group():\n    auth = LocalProfileAuth(user_data_dir=\"./whatsapp_session\")\n    client = Client(auth=auth, headless=True)\n\n    @client.event(\"on_start\")\n    async def on_start():\n        print(\"Client ready. Attempting to add members to a group...\")\n\n        group_name = \"My Awesome WhatsPlay Group\" # Must be an existing group\n        new_members = [\"New Contact Name 1\", \"5491198765432\"]\n\n        success = await client.add_members_to_group(group_name, new_members)\n\n        if success:\n            print(f\"Members added successfully to '{group_name}'.\")\n        else:\n            print(f\"Failed to add members to '{group_name}'.\")\n\n        await client.stop()\n\n    @client.event(\"on_qr\")\n    async def on_qr(qr):\n        print(\"Please scan the QR code to log in.\")\n\n    await client.start()\n\nif __name__ == \"__main__\":\n    asyncio.run(add_members_to_existing_group())\n</code></pre>"},{"location":"guides/group-management/#removing-members-from-a-group","title":"Removing Members from a Group","text":"<p>You can remove members from a group using the <code>client.del_members_from_group()</code> method. Provide the group name and a list of members to remove.</p> <pre><code>import asyncio\nfrom whatsplay import Client\nfrom whatsplay.auth import LocalProfileAuth\n\nasync def remove_members_from_group():\n    auth = LocalProfileAuth(user_data_dir=\"./whatsapp_session\")\n    client = Client(auth=auth, headless=True)\n\n    @client.event(\"on_start\")\n    async def on_start():\n        print(\"Client ready. Attempting to remove members from a group...\")\n\n        group_name = \"My Awesome WhatsPlay Group\" # Must be an existing group\n        members_to_remove = [\"Contact Name To Remove\", \"5491112345678\"]\n\n        success = await client.del_members_from_group(group_name, members_to_remove)\n\n        if success:\n            print(f\"Members removed successfully from '{group_name}'.\")\n        else:\n            print(f\"Failed to remove members from '{group_name}'.\")\n\n        await client.stop()\n\n    @client.event(\"on_qr\")\n    async def on_qr(qr):\n        print(\"Please scan the QR code to log in.\")\n\n    await client.start()\n\nif __name__ == \"__main__\":\n    asyncio.run(remove_members_from_group())\n</code></pre>"},{"location":"guides/group-management/#further-group-management-features-under-consideration","title":"Further Group Management Features (Under Consideration)","text":"<p>While WhatsPlay provides core group management capabilities, future enhancements could include:</p> <ul> <li>Promote/Demote Group Administrators: Functionality to change a member's administrative status.</li> <li>Update Group Information: Methods to change the group's subject (name) or description after creation.</li> <li>Retrieve Detailed Participant List: A way to get a full list of group members along with their roles (admin/participant).</li> </ul> <p>Stay tuned for updates as WhatsPlay evolves!</p>"},{"location":"guides/handling-messages/","title":"Guide: Handling Incoming Messages","text":"<p>WhatsPlay uses an active polling mechanism to detect new messages. Instead of passively waiting for a message event, the client periodically checks for \"unread\" indicators in your chat list.</p> <p>This gives you full control over when and how you process new conversations.</p>"},{"location":"guides/handling-messages/#the-on_unread_chat-event","title":"The <code>on_unread_chat</code> Event","text":"<p>This is the primary event for detecting new activity. It is triggered whenever WhatsPlay finds one or more chats with unread messages.</p> <p>The event handler receives a list of dictionaries, where each dictionary contains basic information about the unread chat (name, last message preview, unread count, etc.).</p>"},{"location":"guides/handling-messages/#basic-pattern-detect-open-and-read","title":"Basic Pattern: Detect, Open, and Read","text":"<p>To read the actual content of the messages, you need to: 1.  Listen for <code>on_unread_chat</code>. 2.  Iterate through the detected chats. 3.  Open each chat using <code>client.open()</code>. 4.  Collect the messages using <code>client.collect_messages()</code>.</p> <pre><code>import asyncio\nfrom whatsplay import Client\nfrom whatsplay.auth import LocalProfileAuth\n\nasync def auto_reply_bot():\n    auth = LocalProfileAuth(user_data_dir=\"./whatsapp_session\")\n    client = Client(auth=auth, headless=True)\n\n    @client.event(\"on_start\")\n    async def on_start():\n        print(\"Bot started! Watching for new messages...\")\n\n    @client.event(\"on_unread_chat\")\n    async def on_unread_chat(chats):\n        \"\"\"\n        Triggered when there are unread chats.\n        'chats' is a list of dicts: [{'name': 'John', 'unread_count': '2', ...}, ...]\n        \"\"\"\n        print(f\"Found {len(chats)} chats with new messages.\")\n\n        for chat_info in chats:\n            chat_name = chat_info.get('name')\n            print(f\"Processing chat: {chat_name}\")\n\n            # 1. Open the chat to load messages\n            if await client.open(chat_name):\n\n                # 2. Collect visible messages\n                messages = await client.collect_messages()\n\n                if messages:\n                    last_message = messages[-1]\n                    sender = last_message.sender.name or \"Unknown\"\n                    text = last_message.text\n\n                    print(f\"  Last message from {sender}: {text}\")\n\n                    # 3. Simple Auto-reply Logic\n                    if text and \"hello\" in text.lower():\n                        await client.send_message(chat_name, \"Hello! I am a WhatsPlay bot. \ud83e\udd16\")\n                        print(f\"  -&gt; Replied to {chat_name}\")\n\n                    # Optional: Mark as read or archive (logic depends on your needs)\n                    # Currently, opening the chat marks it as read in WhatsApp.\n            else:\n                print(f\"  Failed to open chat: {chat_name}\")\n\n    @client.event(\"on_qr\")\n    async def on_qr(qr):\n        print(\"Please scan the QR code.\")\n\n    await client.start()\n\nif __name__ == \"__main__\":\n    asyncio.run(auto_reply_bot())\n</code></pre>"},{"location":"guides/handling-messages/#processing-messages","title":"Processing Messages","text":"<p>The <code>client.collect_messages()</code> method returns a list of <code>Message</code> objects. These are the same objects described in the API Reference.</p>"},{"location":"guides/handling-messages/#common-message-attributes","title":"Common <code>Message</code> Attributes","text":"<ul> <li><code>message.text</code>: The text content.</li> <li><code>message.timestamp</code>: Time the message was received.</li> <li><code>message.sender.name</code>: Name of the sender.</li> <li><code>message.is_media</code>: <code>True</code> if it's an image, video, etc.</li> </ul>"},{"location":"guides/handling-messages/#filtering","title":"Filtering","text":"<p>Since you get a list of messages (usually the last few visible ones), you might want to filter them. While <code>on_message</code> filters (mentioned in other contexts) are for future streaming APIs, you can easily filter the list manually or using Python's built-in tools.</p> <pre><code># Example: Get only messages from today containing \"urgent\"\nrelevant_messages = [\n    m for m in messages \n    if \"urgent\" in (m.text or \"\").lower()\n]\n</code></pre>"},{"location":"guides/handling-messages/#note-on-on_message","title":"Note on <code>on_message</code>","text":"<p>You might see references to an <code>on_message</code> event in the source code. This event is currently reserved for future use and is not emitted automatically by the main loop. Please use the <code>on_unread_chat</code> pattern described above for building bots and automation tools.</p>"},{"location":"guides/sending-media/","title":"Guide: Sending and Receiving Media","text":"<p>WhatsPlay makes it easy to work with media like images, videos, and documents. This guide covers both sending files from your local disk and downloading media from incoming messages.</p>"},{"location":"guides/sending-media/#sending-media","title":"Sending Media","text":"<p>The primary method for sending any kind of file is <code>client.send_file()</code>. You need to provide the recipient (chat name or ID) and the local path to the file. WhatsPlay will handle the rest.</p> <p>You can also provide an optional <code>caption</code> for the media.</p>"},{"location":"guides/sending-media/#example-sending-an-image-with-a-caption","title":"Example: Sending an Image with a Caption","text":"<p>This script sends a local image file to a specified recipient.</p> <pre><code>import asyncio\nfrom pathlib import Path\nfrom whatsplay import Client\nfrom whatsplay.auth import LocalProfileAuth\n\nasync def send_media_file():\n    auth = LocalProfileAuth(user_data_dir=\"./whatsapp_session\")\n    client = Client(auth=auth, headless=True)\n\n    @client.event(\"on_start\")\n    async def on_start():\n        print(\"Client ready. Sending an image...\")\n\n        recipient = \"PHONE_NUMBER_OR_CONTACT_NAME\"\n\n        # Ensure you have an image at this path\n        # For example: /home/user/pictures/my_image.jpg\n        file_path = Path(\"/path/to/your/image.jpg\")\n        caption = \"Here is a picture from WhatsPlay! \ud83d\uddbc\ufe0f\"\n\n        if not file_path.exists():\n            print(f\"Error: File not found at {file_path}\")\n            await client.stop()\n            return\n\n        success = await client.send_file(recipient, file_path, caption=caption)\n\n        if success:\n            print(f\"Media sent successfully to {recipient}.\")\n        else:\n            print(f\"Failed to send media to {recipient}.\")\n\n        await client.stop()\n\n    @client.event(\"on_qr\")\n    async def on_qr(qr):\n        print(\"Please scan the QR code to log in.\")\n\n    await client.start()\n\nif __name__ == \"__main__\":\n    asyncio.run(send_media_file())\n</code></pre> <p>You can use the same <code>client.send_file()</code> method for any file type, including: *   Images (<code>.jpg</code>, <code>.png</code>, etc.) *   Videos (<code>.mp4</code>, <code>.mov</code>, etc.) *   Documents (<code>.pdf</code>, <code>.docx</code>, <code>.zip</code>, etc.) *   Audio files (<code>.mp3</code>, <code>.ogg</code>, etc.)</p>"},{"location":"guides/sending-media/#downloading-media","title":"Downloading Media","text":"<p>When you receive a message that contains media, the <code>Message</code> object provides a convenient way to download it.</p> <ol> <li>Check if the message contains media using <code>message.is_media</code>.</li> <li>If it does, call the <code>await message.download_media()</code> method.</li> </ol> <p>This method downloads the file to a specified location. If no path is provided, it may use a default directory.</p>"},{"location":"guides/sending-media/#example-auto-downloader-bot","title":"Example: Auto-downloader Bot","text":"<p>This bot automatically downloads any media it receives.</p> <pre><code>import asyncio\nfrom pathlib import Path\nfrom whatsplay import Client\nfrom whatsplay.auth import LocalProfileAuth\nfrom whatsplay.event import Message\n\nasync def media_downloader_bot():\n    # Create a directory to save downloaded files\n    download_dir = Path(\"./media_downloads\")\n    download_dir.mkdir(exist_ok=True)\n\n    print(f\"Will save downloaded media to: {download_dir.resolve()}\")\n\n    auth = LocalProfileAuth(user_data_dir=\"./whatsapp_session\")\n    client = Client(auth=auth, headless=True)\n\n    @client.event(\"on_start\")\n    async def on_start():\n        print(\"Downloader bot started. Waiting for media...\")\n\n    @client.event(\"on_message\")\n    async def handle_message(message: Message):\n        if message.is_media:\n            print(f\"Received media of type '{message.media_type}' from {message.sender.name or message.sender.id}.\")\n\n            # Define a path to save the file\n            # You can customize the filename, here we use the message ID\n            save_path = download_dir / f\"{message.id}-{message.media_filename or 'download'}\"\n\n            print(f\"Downloading to {save_path}...\")\n\n            try:\n                await message.download_media(save_path)\n                print(\"Download successful!\")\n                await message.reply(f\"Thanks! I've saved the file as {save_path.name}.\")\n            except Exception as e:\n                print(f\"Error downloading file: {e}\")\n                await message.reply(\"Sorry, I had an error trying to download your file.\")\n\n    @client.event(\"on_qr\")\n    async def on_qr(qr):\n        print(\"Please scan the QR code to log in.\")\n\n    await client.start()\n\nif __name__ == \"__main__\":\n    asyncio.run(media_downloader_bot())\n</code></pre> <p>This bot will listen for incoming messages, and if one contains media, it will attempt to download it into the <code>media_downloads</code> folder in your project directory.</p>"},{"location":"es/","title":"Bienvenido a WhatsPlay","text":"<p>WhatsPlay es una biblioteca de Python para automatizar WhatsApp Web usando Playwright. Proporciona una interfaz simple y basada en eventos para interactuar con chats, enviar mensajes, gestionar grupos y mucho m\u00e1s.</p> <p>Ya sea que quieras construir un bot, automatizar tus reportes diarios o extraer datos de chats, WhatsPlay te da las herramientas para hacerlo eficientemente.</p>"},{"location":"es/#caracteristicas-principales","title":"Caracter\u00edsticas Principales","text":"<ul> <li>Basado en Eventos: Maneja f\u00e1cilmente eventos como mensajes entrantes, escaneos QR o cuando el cliente est\u00e1 listo.</li> <li>API As\u00edncrona Moderna: Construido con <code>asyncio</code> para un alto rendimiento.</li> <li>Gesti\u00f3n de Sesi\u00f3n: Guarda tu sesi\u00f3n localmente para que no tengas que escanear el c\u00f3digo QR cada vez.</li> <li>Gesti\u00f3n de Grupos: Crea grupos, a\u00f1ade/elimina miembros y m\u00e1s.</li> <li>Soporte de Archivos y Multimedia: Env\u00eda im\u00e1genes, documentos y otros archivos con facilidad.</li> </ul>"},{"location":"es/#un-ejemplo-rapido","title":"Un Ejemplo R\u00e1pido","text":"<p>Aqu\u00ed tienes un script simple para enviar un mensaje a un contacto:</p> <pre><code>import asyncio\nfrom whatsplay import Client\nfrom whatsplay.auth import LocalProfileAuth\n\nasync def main():\n    auth = LocalProfileAuth(\"./whatsapp_session\")\n    client = Client(auth=auth, headless=True)\n\n    @client.event(\"on_start\")\n    async def on_start():\n        print(\"\u00a1Cliente iniciado! Enviando mensaje...\")\n\n        # Usa un n\u00famero de tel\u00e9fono (ej., \"1234567890\") o un nombre de contacto guardado\n        # Para n\u00fameros de tel\u00e9fono, incluye el c\u00f3digo de pa\u00eds sin '+' ni '00'\n        recipient = \"NUMERO_DE_TELEFONO_O_NOMBRE_DE_CONTACTO\"\n        message = \"\u00a1Hola desde WhatsPlay! \ud83d\ude80\"\n\n        success = await client.send_message(recipient, message)\n\n        if success:\n            print(f\"Mensaje enviado exitosamente a {recipient}.\")\n        else:\n            print(f\"Fall\u00f3 el env\u00edo del mensaje a {recipient}.\")\n\n        await client.stop()\n\n    # Este evento se dispara si necesitas escanear el c\u00f3digo QR\n    @client.event(\"on_qr\")\n    async def on_qr(qr):\n        print(\"Se requiere escaneo de c\u00f3digo QR. Por favor escanea el QR en el navegador.\")\n\n    await client.start()\n    print(\"Script finalizado.\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"es/api-reference/","title":"Referencia de API","text":"<p>Esta p\u00e1gina proporciona una referencia de API generada autom\u00e1ticamente para los componentes clave de la biblioteca WhatsPlay.</p>"},{"location":"es/api-reference/#client","title":"Client","text":"<p>El <code>Client</code> es el punto de entrada principal para interactuar con WhatsApp.</p>"},{"location":"es/api-reference/#eventos","title":"Eventos","text":"<p>Estos eventos son emitidos por el <code>Client</code> y pueden ser manejados usando el decorador <code>@client.event</code>.</p> Evento Condici\u00f3n de Disparo Argumentos <code>on_start</code> El cliente se ha inicializado correctamente y la p\u00e1gina del navegador est\u00e1 abierta. Ninguno <code>on_auth</code> Se muestra la pantalla de autenticaci\u00f3n (p\u00e1gina del c\u00f3digo QR). Ninguno <code>on_qr</code> Se detecta un nuevo c\u00f3digo QR por primera vez. <code>qr_binary</code> (bytes) <code>on_qr_change</code> El c\u00f3digo QR mostrado se ha actualizado/cambiado. <code>qr_binary</code> (bytes) <code>on_logged_in</code> El cliente ha iniciado sesi\u00f3n exitosamente en WhatsApp Web. Ninguno <code>on_loading</code> La pantalla \"Cargando chats\" es visible. <code>is_loading</code> (bool) <code>on_unread_chat</code> Se detectan chats no le\u00eddos en la barra lateral. Verificaci\u00f3n peri\u00f3dica. <code>chats</code> (List[Dict]) <code>on_stop</code> El cliente se est\u00e1 deteniendo y limpiando recursos. Ninguno <code>on_disconnect</code> El cliente ha perdido la conexi\u00f3n con el navegador/WhatsApp. Ninguno <code>on_reconnect</code> El cliente se ha reconectado exitosamente. Ninguno <code>on_state_change</code> El estado interno del cliente (ej. AUTH, LOGGED_IN) ha cambiado. <code>state</code> (State enum) <code>on_tick</code> Emitido en cada iteraci\u00f3n del bucle principal de eventos. Ninguno <code>on_error</code> Ha ocurrido un error. <code>message</code> (str) <code>on_warning</code> Ha ocurrido un problema no cr\u00edtico. <code>message</code> (str) <code>on_info</code> Mensaje informativo. <code>message</code> (str) <p>Nota: El evento <code>on_message</code> est\u00e1 reservado para uso futuro. Actualmente, use <code>on_unread_chat</code> para detectar nueva actividad.</p>"},{"location":"es/api-reference/#objetos-de-evento","title":"Objetos de Evento","text":"<p>Estos son los objetos que se pasan a sus manejadores de eventos.</p>"},{"location":"es/api-reference/#message","title":"Message","text":"<p>El objeto <code>Message</code> representa un mensaje recuperado de un chat (por ejemplo, v\u00eda <code>chat_manager.collect_messages()</code>).</p>"},{"location":"es/api-reference/#gestores-managers","title":"Gestores (Managers)","text":"<p>Gestores internos que manejan diferentes aspectos de la funcionalidad del cliente.</p>"},{"location":"es/api-reference/#chat-manager","title":"Chat Manager","text":"<p>Responsable de buscar y gestionar chats.</p>"},{"location":"es/api-reference/#state-manager","title":"State Manager","text":"<p>Responsable de gestionar el estado interno del cliente.</p>"},{"location":"es/api-reference/#autenticacion","title":"Autenticaci\u00f3n","text":"<p>Los manejadores de autenticaci\u00f3n se utilizan para gestionar la sesi\u00f3n de WhatsApp.</p>"},{"location":"es/api-reference/#local-profile-auth","title":"Local Profile Auth","text":"<p>El manejador recomendado para guardar su sesi\u00f3n localmente y evitar escaneos QR repetidos.</p>"},{"location":"es/api-reference/#no-auth","title":"No Auth","text":"<p>Un manejador que no guarda ning\u00fan dato de sesi\u00f3n, requiriendo un nuevo inicio de sesi\u00f3n en cada ejecuci\u00f3n.</p>"},{"location":"es/api-reference/#filtros","title":"Filtros","text":"<p>El m\u00f3dulo <code>filters</code> proporciona clases e instancias para filtrar eventos.</p>"},{"location":"es/api-reference/#filtros-de-mensaje-predefinidos","title":"Filtros de Mensaje Predefinidos","text":"<p>Una colecci\u00f3n de filtros listos para usar para el evento <code>on_message</code>.</p>"},{"location":"es/api-reference/#clase-base-de-filtro-personalizado","title":"Clase Base de Filtro Personalizado","text":"<p>Herede de esta clase para crear sus propios filtros potentes y reutilizables.</p>"},{"location":"es/getting-started/","title":"Empezando con WhatsPlay","text":"<p>Esta gu\u00eda te llevar\u00e1 a trav\u00e9s de la instalaci\u00f3n de WhatsPlay y la escritura de tu primer script para enviar un mensaje de WhatsApp.</p>"},{"location":"es/getting-started/#1-instalacion","title":"1. Instalaci\u00f3n","text":"<p>WhatsPlay requiere Python 3.8 o superior. Puedes instalarlo directamente desde PyPI. Tambi\u00e9n recomendamos instalar las dependencias del navegador de Playwright.</p> <p>Primero, instala la biblioteca:</p> <pre><code>pip install whatsplay\n</code></pre> <p>Luego, instala los binarios del navegador necesarios para Playwright (esto descargar\u00e1 un navegador como Chromium):</p> <pre><code>playwright install\n</code></pre>"},{"location":"es/getting-started/#2-tu-primer-script-enviando-un-mensaje","title":"2. Tu Primer Script: Enviando un Mensaje","text":"<p>Vamos a crear un script simple que inicie sesi\u00f3n en WhatsApp y env\u00ede un mensaje.</p> <p>Crea un nuevo archivo Python, por ejemplo <code>enviar_hola.py</code>, y a\u00f1ade el siguiente c\u00f3digo.</p> <pre><code>import asyncio\nfrom whatsplay import Client\nfrom whatsplay.auth import LocalProfileAuth\n\nasync def main():\n    \"\"\"\n    Funci\u00f3n principal para inicializar el cliente, enviar un mensaje y detenerse.\n    \"\"\"\n\n    # --- Paso 1: Configurar Autenticaci\u00f3n ---\n    # Esto le dice a WhatsPlay que guarde los datos de sesi\u00f3n en una carpeta llamada \"whatsapp_session\".\n    # De esta manera, solo necesitas escanear el c\u00f3digo QR una vez.\n    auth = LocalProfileAuth(user_data_dir=\"./whatsapp_session\")\n\n    # --- Paso 2: Inicializar el Cliente ---\n    # Ejecutamos en headless=False la primera vez para facilitar el escaneo del c\u00f3digo QR.\n    # Puedes cambiarlo a headless=True despu\u00e9s para ejecuci\u00f3n en segundo plano.\n    client = Client(auth=auth, headless=False)\n\n    # --- Paso 3: Definir Manejadores de Eventos ---\n    # `on_start` se dispara una vez que el cliente ha iniciado sesi\u00f3n y est\u00e1 listo.\n    @client.event(\"on_start\")\n    async def on_start():\n        print(\"\u00a1El cliente est\u00e1 listo! Preparando para enviar un mensaje...\")\n\n        # Define tu destinatario y mensaje\n        # IMPORTANTE: Reemplaza con un n\u00famero de tel\u00e9fono real o nombre de contacto.\n        # Para n\u00fameros de tel\u00e9fono, usa el formato con c\u00f3digo de pa\u00eds pero sin '+' ni '00'.\n        recipient = \"1234567890\" \n        message = \"\u00a1Este es mi primer mensaje desde WhatsPlay! \ud83c\udf89\"\n\n        # Enviar el mensaje\n        success = await client.send_message(recipient, message)\n\n        if success:\n            print(f\"\u00a1Mensaje enviado exitosamente a {recipient}!\")\n        else:\n            print(f\"\u00a1Ups! Fall\u00f3 el env\u00edo del mensaje a {recipient}.\")\n\n        # Detener el cliente despu\u00e9s de terminar el trabajo\n        print(\"Trabajo completo. Apagando...\")\n        await client.stop()\n\n    # `on_qr` se dispara si se necesita un escaneo QR.\n    @client.event(\"on_qr\")\n    async def on_qr(qr):\n        print(\"Inicio de sesi\u00f3n requerido. Se deber\u00eda abrir una ventana del navegador para escanear el c\u00f3digo QR.\")\n\n    # `on_auth` se dispara si se requiere autenticaci\u00f3n\n    @client.event(\"on_auth\")\n    async def on_auth():\n        print(\"Se requiere autenticaci\u00f3n.\")\n\n    # `on_error` captura errores potenciales durante la ejecuci\u00f3n\n    @client.event(\"on_error\")\n    async def on_error(error):\n        print(f\"Ocurri\u00f3 un error: {error}\")\n        await client.stop()\n\n    # --- Paso 4: Iniciar el Cliente ---\n    # Esta llamada inicia el navegador y comienza el proceso de inicio de sesi\u00f3n.\n    await client.start()\n    print(\"El script ha terminado de ejecutarse.\")\n\n# --- Ejecutar la funci\u00f3n principal ---\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"es/getting-started/#como-ejecutarlo","title":"C\u00f3mo Ejecutarlo","text":"<ol> <li>Guarda el c\u00f3digo: Guarda el script como <code>enviar_hola.py</code>.</li> <li>Modifica el destinatario: Cambia <code>\"1234567890\"</code> a un n\u00famero de tel\u00e9fono real o un nombre de contacto guardado en tu WhatsApp.</li> <li>Ejecuta desde tu terminal: <pre><code>python enviar_hola.py\n</code></pre></li> <li>Inicio de sesi\u00f3n por primera vez: Se abrir\u00e1 una ventana del navegador. Escanea el c\u00f3digo QR de WhatsApp Web con tu tel\u00e9fono.</li> <li>Ejecuciones subsiguientes: El script reutilizar\u00e1 la sesi\u00f3n y deber\u00eda iniciar sesi\u00f3n autom\u00e1ticamente. El mensaje se enviar\u00e1 y el script saldr\u00e1.</li> </ol>"},{"location":"es/guides/advanced-features/","title":"Gu\u00eda: Caracter\u00edsticas Avanzadas","text":"<p>M\u00e1s all\u00e1 de enviar y recibir mensajes, WhatsPlay ofrece varias caracter\u00edsticas avanzadas para ayudarte a gestionar tus chats e interactuar de forma m\u00e1s natural.</p>"},{"location":"es/guides/advanced-features/#buscando-conversaciones","title":"Buscando Conversaciones","text":"<p>Si tienes una larga lista de chats, puedes usar la funci\u00f3n de b\u00fasqueda para encontrar contactos o grupos espec\u00edficos.</p> <pre><code># Buscar un contacto o grupo\n# Devuelve una lista de resultados coincidentes\nresults = await client.search_conversations(\"Proyecto Alpha\")\n\nfor result in results:\n    print(f\"Encontrado: {result['name']}\")\n    # Luego puedes abrirlo usando el nombre exacto\n    await client.open(result['name'])\n</code></pre>"},{"location":"es/guides/advanced-features/#reaccionando-a-mensajes","title":"Reaccionando a Mensajes","text":"<p>Puedes reaccionar al \u00faltimo mensaje recibido en un chat usando emojis. Esto es genial para confirmar la recepci\u00f3n sin enviar un mensaje de texto completo.</p> <pre><code>await client.open(\"Mi Amigo\")\n\n# Reaccionar con un pulgar arriba\nsuccess = await client.react_to_last_message(\"\ud83d\udc4d\")\n\nif success:\n    print(\"\u00a1Reacci\u00f3n enviada exitosamente!\")\n</code></pre>"},{"location":"es/guides/advanced-features/#descargando-todos-los-archivos","title":"Descargando Todos los Archivos","text":"<p>Si necesitas archivar multimedia o documentos de un chat, <code>download_all_files</code> te permite obtener todos los adjuntos visibles en la vista actual.</p> <pre><code>await client.open(\"Grupo Familiar\")\n\n# Descargar todos los archivos visibles a una carpeta espec\u00edfica\nsaved_paths = await client.download_all_files(carpeta=\"./descargas/fotos_familia\")\n\nprint(f\"Descargados {len(saved_paths)} archivos.\")\n</code></pre>"},{"location":"es/guides/advanced-features/#extrayendo-historial-de-chat-scraping","title":"Extrayendo Historial de Chat (Scraping)","text":"<p>Puedes combinar <code>open</code> y <code>collect_messages</code> para extraer el historial de chat. Ten en cuenta que WhatsPlay interact\u00faa actualmente con el DOM visible.</p> <pre><code>await client.open(\"Chat de Trabajo\")\n\n# Obtener todos los mensajes cargados actualmente\nmessages = await client.collect_messages()\n\nfor msg in messages:\n    print(f\"[{msg.timestamp}] {msg.sender.name}: {msg.text}\")\n</code></pre>"},{"location":"es/guides/group-management/","title":"Gu\u00eda: Administraci\u00f3n de Grupos","text":"<p>WhatsPlay proporciona una funcionalidad robusta para gestionar grupos de WhatsApp, permiti\u00e9ndote crear nuevos grupos y gestionar sus miembros program\u00e1ticamente.</p>"},{"location":"es/guides/group-management/#creando-un-nuevo-grupo","title":"Creando un Nuevo Grupo","text":"<p>Puedes crear un nuevo grupo de WhatsApp usando el m\u00e9todo <code>client.new_group()</code>. Este m\u00e9todo requiere un nombre de grupo y una lista de nombres de contacto o n\u00fameros de tel\u00e9fono para los miembros iniciales.</p> <p>Importante: Los contactos en la lista <code>members</code> ya deben estar en tus contactos de WhatsApp o ser n\u00fameros de tel\u00e9fono v\u00e1lidos (incluyendo c\u00f3digo de pa\u00eds, sin '+' ni '00').</p> <pre><code>import asyncio\nfrom whatsplay import Client\nfrom whatsplay.auth import LocalProfileAuth\n\nasync def create_my_group():\n    auth = LocalProfileAuth(user_data_dir=\"./whatsapp_session\")\n    client = Client(auth=auth, headless=True) # Establece headless=False si quieres ver el navegador\n\n    @client.event(\"on_start\")\n    async def on_start():\n        print(\"Cliente listo. Intentando crear un nuevo grupo...\")\n\n        group_name = \"Mi Grupo Incre\u00edble de WhatsPlay\"\n        # Usa nombres de contacto existentes o n\u00fameros de tel\u00e9fono\n        initial_members = [\"Nombre Contacto 1\", \"5491123456789\"] # Ejemplo: \"54911...\" para m\u00f3vil de Argentina\n\n        success = await client.new_group(group_name, initial_members)\n\n        if success:\n            print(f\"Grupo '{group_name}' creado exitosamente con miembros iniciales.\")\n        else:\n            print(f\"Fall\u00f3 la creaci\u00f3n del grupo '{group_name}'.\")\n\n        await client.stop()\n\n    @client.event(\"on_qr\")\n    async def on_qr(qr):\n        print(\"Por favor escanea el c\u00f3digo QR para iniciar sesi\u00f3n.\")\n\n    await client.start()\n\nif __name__ == \"__main__\":\n    asyncio.run(create_my_group())\n</code></pre>"},{"location":"es/guides/group-management/#anadiendo-miembros-a-un-grupo-existente","title":"A\u00f1adiendo Miembros a un Grupo Existente","text":"<p>Para a\u00f1adir m\u00e1s miembros a un grupo ya existente, usa el m\u00e9todo <code>client.add_members_to_group()</code>. Necesitas proporcionar el nombre del grupo y una lista de miembros para a\u00f1adir.</p> <pre><code>import asyncio\nfrom whatsplay import Client\nfrom whatsplay.auth import LocalProfileAuth\n\nasync def add_members_to_existing_group():\n    auth = LocalProfileAuth(user_data_dir=\"./whatsapp_session\")\n    client = Client(auth=auth, headless=True)\n\n    @client.event(\"on_start\")\n    async def on_start():\n        print(\"Cliente listo. Intentando a\u00f1adir miembros a un grupo...\")\n\n        group_name = \"Mi Grupo Incre\u00edble de WhatsPlay\" # Debe ser un grupo existente\n        new_members = [\"Nuevo Nombre Contacto 1\", \"5491198765432\"]\n\n        success = await client.add_members_to_group(group_name, new_members)\n\n        if success:\n            print(f\"Miembros a\u00f1adidos exitosamente a '{group_name}'.\")\n        else:\n            print(f\"Fall\u00f3 al a\u00f1adir miembros a '{group_name}'.\")\n\n        await client.stop()\n\n    @client.event(\"on_qr\")\n    async def on_qr(qr):\n        print(\"Por favor escanea el c\u00f3digo QR para iniciar sesi\u00f3n.\")\n\n    await client.start()\n\nif __name__ == \"__main__\":\n    asyncio.run(add_members_to_existing_group())\n</code></pre>"},{"location":"es/guides/group-management/#eliminando-miembros-de-un-grupo","title":"Eliminando Miembros de un Grupo","text":"<p>Puedes eliminar miembros de un grupo usando el m\u00e9todo <code>client.del_members_from_group()</code>. Proporciona el nombre del grupo y una lista de miembros a eliminar.</p> <pre><code>import asyncio\nfrom whatsplay import Client\nfrom whatsplay.auth import LocalProfileAuth\n\nasync def remove_members_from_group():\n    auth = LocalProfileAuth(user_data_dir=\"./whatsapp_session\")\n    client = Client(auth=auth, headless=True)\n\n    @client.event(\"on_start\")\n    async def on_start():\n        print(\"Cliente listo. Intentando eliminar miembros de un grupo...\")\n\n        group_name = \"Mi Grupo Incre\u00edble de WhatsPlay\" # Debe ser un grupo existente\n        members_to_remove = [\"Nombre Contacto A Eliminar\", \"5491112345678\"]\n\n        success = await client.del_members_from_group(group_name, members_to_remove)\n\n        if success:\n            print(f\"Miembros eliminados exitosamente de '{group_name}'.\")\n        else:\n            print(f\"Fall\u00f3 al eliminar miembros de '{group_name}'.\")\n\n        await client.stop()\n\n    @client.event(\"on_qr\")\n    async def on_qr(qr):\n        print(\"Por favor escanea el c\u00f3digo QR para iniciar sesi\u00f3n.\")\n\n    await client.start()\n\nif __name__ == \"__main__\":\n    asyncio.run(remove_members_from_group())\n</code></pre>"},{"location":"es/guides/group-management/#caracteristicas-futuras-de-gestion-de-grupos-bajo-consideracion","title":"Caracter\u00edsticas Futuras de Gesti\u00f3n de Grupos (Bajo Consideraci\u00f3n)","text":"<p>Aunque WhatsPlay proporciona capacidades centrales de gesti\u00f3n de grupos, mejoras futuras podr\u00edan incluir:</p> <ul> <li>Promover/Degradar Administradores de Grupo: Funcionalidad para cambiar el estado administrativo de un miembro.</li> <li>Actualizar Informaci\u00f3n del Grupo: M\u00e9todos para cambiar el asunto (nombre) o descripci\u00f3n del grupo despu\u00e9s de la creaci\u00f3n.</li> <li>Obtener Lista Detallada de Participantes: Una forma de obtener una lista completa de miembros del grupo junto con sus roles (admin/participante).</li> </ul> <p>\u00a1Mantente atento a las actualizaciones a medida que WhatsPlay evoluciona!</p>"},{"location":"es/guides/handling-messages/","title":"Gu\u00eda: Manejo de Mensajes Entrantes","text":"<p>WhatsPlay utiliza un mecanismo de sondeo (polling) activo para detectar nuevos mensajes. En lugar de esperar pasivamente un evento de mensaje, el cliente verifica peri\u00f3dicamente si hay indicadores de \"no le\u00eddo\" en tu lista de chats.</p> <p>Esto te da control total sobre cu\u00e1ndo y c\u00f3mo procesas nuevas conversaciones.</p>"},{"location":"es/guides/handling-messages/#el-evento-on_unread_chat","title":"El Evento <code>on_unread_chat</code>","text":"<p>Este es el evento principal para detectar nueva actividad. Se dispara cada vez que WhatsPlay encuentra uno o m\u00e1s chats con mensajes no le\u00eddos.</p> <p>El manejador del evento recibe una lista de diccionarios, donde cada diccionario contiene informaci\u00f3n b\u00e1sica sobre el chat no le\u00eddo (nombre, vista previa del \u00faltimo mensaje, contador de no le\u00eddos, etc.).</p>"},{"location":"es/guides/handling-messages/#patron-basico-detectar-abrir-y-leer","title":"Patr\u00f3n B\u00e1sico: Detectar, Abrir y Leer","text":"<p>Para leer el contenido real de los mensajes, necesitas: 1.  Escuchar el evento <code>on_unread_chat</code>. 2.  Iterar a trav\u00e9s de los chats detectados. 3.  Abrir cada chat usando <code>client.open()</code>. 4.  Recolectar los mensajes usando <code>client.collect_messages()</code>.</p> <pre><code>import asyncio\nfrom whatsplay import Client\nfrom whatsplay.auth import LocalProfileAuth\n\nasync def auto_reply_bot():\n    auth = LocalProfileAuth(user_data_dir=\"./whatsapp_session\")\n    client = Client(auth=auth, headless=True)\n\n    @client.event(\"on_start\")\n    async def on_start():\n        print(\"\u00a1Bot iniciado! Buscando nuevos mensajes...\")\n\n    @client.event(\"on_unread_chat\")\n    async def on_unread_chat(chats):\n        \"\"\"\n        Se dispara cuando hay chats no le\u00eddos.\n        'chats' es una lista de dicts: [{'name': 'Juan', 'unread_count': '2', ...}, ...]\n        \"\"\"\n        print(f\"Se encontraron {len(chats)} chats con nuevos mensajes.\")\n\n        for chat_info in chats:\n            chat_name = chat_info.get('name')\n            print(f\"Procesando chat: {chat_name}\")\n\n            # 1. Abrir el chat para cargar los mensajes\n            if await client.open(chat_name):\n\n                # 2. Recolectar mensajes visibles\n                messages = await client.collect_messages()\n\n                if messages:\n                    last_message = messages[-1]\n                    sender = last_message.sender.name or \"Desconocido\"\n                    text = last_message.text\n\n                    print(f\"  \u00daltimo mensaje de {sender}: {text}\")\n\n                    # 3. L\u00f3gica simple de Auto-respuesta\n                    if text and \"hola\" in text.lower():\n                        await client.send_message(chat_name, \"\u00a1Hola! Soy un bot de WhatsPlay. \ud83e\udd16\")\n                        print(f\"  -&gt; Respondido a {chat_name}\")\n\n                    # Opcional: Marcar como le\u00eddo o archivar (la l\u00f3gica depende de tus necesidades)\n                    # Actualmente, abrir el chat lo marca como le\u00eddo en WhatsApp.\n            else:\n                print(f\"  Fall\u00f3 al abrir el chat: {chat_name}\")\n\n    @client.event(\"on_qr\")\n    async def on_qr(qr):\n        print(\"Por favor escanea el c\u00f3digo QR.\")\n\n    await client.start()\n\nif __name__ == \"__main__\":\n    asyncio.run(auto_reply_bot())\n</code></pre>"},{"location":"es/guides/handling-messages/#procesando-mensajes","title":"Procesando Mensajes","text":"<p>El m\u00e9todo <code>client.collect_messages()</code> devuelve una lista de objetos <code>Message</code>. Estos son los mismos objetos descritos en la Referencia de la API.</p>"},{"location":"es/guides/handling-messages/#atributos-comunes-de-message","title":"Atributos Comunes de <code>Message</code>","text":"<ul> <li><code>message.text</code>: El contenido de texto.</li> <li><code>message.timestamp</code>: Hora en que se recibi\u00f3 el mensaje.</li> <li><code>message.sender.name</code>: Nombre del remitente.</li> <li><code>message.is_media</code>: <code>True</code> si es una imagen, video, etc.</li> </ul>"},{"location":"es/guides/handling-messages/#filtrado","title":"Filtrado","text":"<p>Dado que obtienes una lista de mensajes (usualmente los \u00faltimos visibles), podr\u00edas querer filtrarlos. Aunque los filtros de <code>on_message</code> (mencionados en otros contextos) son para futuras APIs de streaming, puedes filtrar f\u00e1cilmente la lista manualmente o usando herramientas integradas de Python.</p> <pre><code># Ejemplo: Obtener solo mensajes que contengan \"urgente\"\nmensajes_relevantes = [\n    m for m in messages \n    if \"urgente\" in (m.text or \"\").lower()\n]\n</code></pre>"},{"location":"es/guides/handling-messages/#nota-sobre-on_message","title":"Nota sobre <code>on_message</code>","text":"<p>Podr\u00edas ver referencias a un evento <code>on_message</code> en el c\u00f3digo fuente. Este evento est\u00e1 actualmente reservado para uso futuro y no es emitido autom\u00e1ticamente por el bucle principal. Por favor, utiliza el patr\u00f3n <code>on_unread_chat</code> descrito anteriormente para construir bots y herramientas de automatizaci\u00f3n.</p>"},{"location":"es/guides/sending-media/","title":"Gu\u00eda: Env\u00edo y Recepci\u00f3n de Archivos Multimedia","text":"<p>WhatsPlay hace f\u00e1cil trabajar con multimedia como im\u00e1genes, videos y documentos. Esta gu\u00eda cubre tanto el env\u00edo de archivos desde tu disco local como la descarga de medios de mensajes entrantes.</p>"},{"location":"es/guides/sending-media/#enviando-multimedia","title":"Enviando Multimedia","text":"<p>El m\u00e9todo principal para enviar cualquier tipo de archivo es <code>client.send_file()</code>. Necesitas proporcionar el destinatario (nombre de chat o ID) y la ruta local al archivo. WhatsPlay manejar\u00e1 el resto.</p> <p>Tambi\u00e9n puedes proporcionar un <code>caption</code> opcional para el medio.</p>"},{"location":"es/guides/sending-media/#ejemplo-enviando-una-imagen-con-una-leyenda","title":"Ejemplo: Enviando una Imagen con una Leyenda","text":"<p>Este script env\u00eda un archivo de imagen local a un destinatario especificado.</p> <pre><code>import asyncio\nfrom pathlib import Path\nfrom whatsplay import Client\nfrom whatsplay.auth import LocalProfileAuth\n\nasync def send_media_file():\n    auth = LocalProfileAuth(user_data_dir=\"./whatsapp_session\")\n    client = Client(auth=auth, headless=True)\n\n    @client.event(\"on_start\")\n    async def on_start():\n        print(\"Cliente listo. Enviando una imagen...\")\n\n        recipient = \"NUMERO_DE_TELEFONO_O_NOMBRE_DE_CONTACTO\"\n\n        # Aseg\u00farate de tener una imagen en esta ruta\n        # Por ejemplo: /home/user/pictures/mi_imagen.jpg\n        file_path = Path(\"/path/to/your/image.jpg\")\n        caption = \"\u00a1Aqu\u00ed hay una foto desde WhatsPlay! \ud83d\uddbc\ufe0f\"\n\n        if not file_path.exists():\n            print(f\"Error: Archivo no encontrado en {file_path}\")\n            await client.stop()\n            return\n\n        success = await client.send_file(recipient, file_path, caption=caption)\n\n        if success:\n            print(f\"Multimedia enviada exitosamente a {recipient}.\")\n        else:\n            print(f\"Fall\u00f3 el env\u00edo de multimedia a {recipient}.\")\n\n        await client.stop()\n\n    @client.event(\"on_qr\")\n    async def on_qr(qr):\n        print(\"Por favor escanea el c\u00f3digo QR para iniciar sesi\u00f3n.\")\n\n    await client.start()\n\nif __name__ == \"__main__\":\n    asyncio.run(send_media_file())\n</code></pre> <p>Puedes usar el mismo m\u00e9todo <code>client.send_file()</code> para cualquier tipo de archivo, incluyendo: *   Im\u00e1genes (<code>.jpg</code>, <code>.png</code>, etc.) *   Videos (<code>.mp4</code>, <code>.mov</code>, etc.) *   Documentos (<code>.pdf</code>, <code>.docx</code>, <code>.zip</code>, etc.) *   Archivos de audio (<code>.mp3</code>, <code>.ogg</code>, etc.)</p>"},{"location":"es/guides/sending-media/#descargando-multimedia","title":"Descargando Multimedia","text":"<p>Cuando recibes un mensaje que contiene multimedia, el objeto <code>Message</code> proporciona una forma conveniente de descargarlo.</p> <ol> <li>Verifica si el mensaje contiene medios usando <code>message.is_media</code>.</li> <li>Si lo hace, llama al m\u00e9todo <code>await message.download_media()</code>.</li> </ol> <p>Este m\u00e9todo descarga el archivo a una ubicaci\u00f3n especificada. Si no se proporciona una ruta, puede usar un directorio por defecto.</p>"},{"location":"es/guides/sending-media/#ejemplo-bot-auto-descargador","title":"Ejemplo: Bot Auto-descargador","text":"<p>Este bot descarga autom\u00e1ticamente cualquier medio que recibe.</p> <pre><code>import asyncio\nfrom pathlib import Path\nfrom whatsplay import Client\nfrom whatsplay.auth import LocalProfileAuth\nfrom whatsplay.event import Message\n\nasync def media_downloader_bot():\n    # Crear un directorio para guardar archivos descargados\n    download_dir = Path(\"./media_downloads\")\n    download_dir.mkdir(exist_ok=True)\n\n    print(f\"Guardar\u00e9 los medios descargados en: {download_dir.resolve()}\")\n\n    auth = LocalProfileAuth(user_data_dir=\"./whatsapp_session\")\n    client = Client(auth=auth, headless=True)\n\n    @client.event(\"on_start\")\n    async def on_start():\n        print(\"Bot descargador iniciado. Esperando medios...\")\n\n    @client.event(\"on_message\")\n    async def handle_message(message: Message):\n        if message.is_media:\n            print(f\"Recib\u00ed medio de tipo '{message.media_type}' de {message.sender.name or message.sender.id}.\")\n\n            # Definir una ruta para guardar el archivo\n            # Puedes personalizar el nombre de archivo, aqu\u00ed usamos el ID del mensaje\n            save_path = download_dir / f\"{message.id}-{message.media_filename or 'download'}\"\n\n            print(f\"Descargando a {save_path}...\")\n\n            try:\n                await message.download_media(save_path)\n                print(\"\u00a1Descarga exitosa!\")\n                await message.reply(f\"\u00a1Gracias! He guardado el archivo como {save_path.name}.\")\n            except Exception as e:\n                print(f\"Error descargando archivo: {e}\")\n                await message.reply(\"Lo siento, tuve un error intentando descargar tu archivo.\")\n\n    @client.event(\"on_qr\")\n    async def on_qr(qr):\n        print(\"Por favor escanea el c\u00f3digo QR para iniciar sesi\u00f3n.\")\n\n    await client.start()\n\nif __name__ == \"__main__\":\n    asyncio.run(media_downloader_bot())\n</code></pre> <p>Este bot escuchar\u00e1 mensajes entrantes, y si uno contiene multimedia, intentar\u00e1 descargarlo en la carpeta <code>media_downloads</code> en tu directorio de proyecto.</p>"}]}