{"config":{"lang":["en","es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to WhatsPlay","text":"<p>WhatsPlay is a Python library for automating WhatsApp Web using Playwright. It provides a simple, event-driven interface to interact with chats, send messages, manage groups, and much more.</p> <p>Whether you want to build a bot, automate your daily reports, or scrape chat data, WhatsPlay gives you the tools to do it efficiently.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Event-Driven: Easily handle events like incoming messages, QR scans, or when the client is ready.</li> <li>Modern Async API: Built with <code>asyncio</code> for high performance.</li> <li>Session Management: Saves your session locally so you don't have to scan the QR code every time.</li> <li>Group Management: Create groups, add/remove members, and more.</li> <li>File &amp; Media Support: Send images, documents, and other files with ease.</li> </ul>"},{"location":"#a-quick-example","title":"A Quick Example","text":"<p>Here's a simple script to send a message to a contact:</p> <pre><code>import asyncio\nfrom whatsplay import Client\nfrom whatsplay.auth import LocalProfileAuth\n\nasync def main():\n    auth = LocalProfileAuth(\"./whatsapp_session\")\n    client = Client(auth=auth, headless=True)\n\n    @client.event(\"on_start\")\n    async def on_start():\n        print(\"Client started! Sending message...\")\n\n        # Use a phone number (e.g., \"1234567890\") or a saved contact name\n        # For phone numbers, include the country code without '+' or '00'\n        recipient = \"PHONE_NUMBER_OR_CONTACT_NAME\"\n        message = \"Hello from WhatsPlay! \ud83d\ude80\"\n\n        success = await client.send_message(recipient, message)\n\n        if success:\n            print(f\"Message sent successfully to {recipient}.\")\n        else:\n            print(f\"Failed to send message to {recipient}.\")\n\n        await client.stop()\n\n    # This event is triggered if you need to scan the QR code\n    @client.event(\"on_qr\")\n    async def on_qr(qr):\n        print(\"QR code scan is required. Please scan the QR in the browser.\")\n\n    await client.start()\n    print(\"Script finished.\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"api-reference/","title":"API Reference","text":"<p>This page provides an auto-generated API reference for the key components of the WhatsPlay library.</p>"},{"location":"api-reference/#client","title":"Client","text":"<p>The <code>Client</code> is the main entry point for interacting with WhatsApp.</p>"},{"location":"api-reference/#whatsplay.client.Client","title":"<code>whatsplay.client.Client</code>","text":"<p>               Bases: <code>BaseWhatsAppClient</code></p> <p>High-level WhatsApp Web client with full automation capabilities.</p> <p>This client provides a complete interface for WhatsApp Web automation including authentication, chat management, message sending, and event handling.</p> <p>Attributes:</p> Name Type Description <code>locale</code> <p>Locale for the browser (default: \"en-US\")</p> <code>poll_freq</code> <p>Frequency of state polling in seconds</p> <code>current_state</code> <code>Optional[State]</code> <p>Current WhatsApp Web state</p> <code>unread_messages_sleep</code> <p>Sleep time between unread message checks</p> <code>wa_elements</code> <code>Optional[WhatsAppElements]</code> <p>WhatsApp Web elements helper</p> <code>chat_manager</code> <code>Optional[ChatManager]</code> <p>Chat operations manager</p> <code>state_manager</code> <code>Optional[StateManager]</code> <p>State transition manager</p> Example <p>client = Client(auth=LocalProfileAuth(\"./session\")) @client.event(\"on_logged_in\") ... async def on_ready(): ...     print(\"Client is ready!\") await client.start()</p> Source code in <code>src/whatsplay/client.py</code> <pre><code>class Client(BaseWhatsAppClient):\n    \"\"\"\n    High-level WhatsApp Web client with full automation capabilities.\n\n    This client provides a complete interface for WhatsApp Web automation\n    including authentication, chat management, message sending, and event handling.\n\n    Attributes:\n        locale: Locale for the browser (default: \"en-US\")\n        poll_freq: Frequency of state polling in seconds\n        current_state: Current WhatsApp Web state\n        unread_messages_sleep: Sleep time between unread message checks\n        wa_elements: WhatsApp Web elements helper\n        chat_manager: Chat operations manager\n        state_manager: State transition manager\n\n    Example:\n        &gt;&gt;&gt; client = Client(auth=LocalProfileAuth(\"./session\"))\n        &gt;&gt;&gt; @client.event(\"on_logged_in\")\n        ... async def on_ready():\n        ...     print(\"Client is ready!\")\n        &gt;&gt;&gt; await client.start()\n    \"\"\"\n\n    def __init__(\n        self,\n        user_data_dir: Optional[str] = None,\n        headless: bool = False,\n        locale: str = \"en-US\",\n        auth: Optional[Any] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the WhatsApp Web client.\n\n        Args:\n            user_data_dir: Directory for browser profile data\n            headless: Run browser in headless mode\n            locale: Browser locale setting\n            auth: Authentication provider instance\n        \"\"\"\n        super().__init__(user_data_dir=user_data_dir, headless=headless, auth=auth)\n        self.locale = locale\n        self._cached_chats: set = set()\n        self.poll_freq = DEFAULT_POLL_FREQUENCY\n        self.wa_elements: Optional[WhatsAppElements] = None\n        self.qr_task: Optional[asyncio.Task] = None\n        self.current_state: Optional[State] = None\n        self.unread_messages_sleep = DEFAULT_UNREAD_MESSAGES_SLEEP\n        self._shutdown_event = asyncio.Event()\n        self._consecutive_errors = 0\n        self.last_qr_shown: Optional[bytes] = None\n        self.chat_manager: Optional[ChatManager] = None\n        self.state_manager: Optional[StateManager] = None\n        self._setup_signal_handlers()\n\n    def _setup_signal_handlers(self) -&gt; None:\n        \"\"\"\n        Configure signal handlers for clean shutdown.\n\n        Sets up handlers for SIGINT and SIGTERM to ensure proper cleanup\n        when the process is terminated.\n        \"\"\"\n        if sys.platform != \"win32\":\n            for sig in (signal.SIGINT, signal.SIGTERM):\n                try:\n                    asyncio.get_event_loop().add_signal_handler(\n                        sig, lambda s=sig: asyncio.create_task(self._handle_signal(s))\n                    )\n                except (NotImplementedError, RuntimeError):\n                    signal.signal(\n                        sig, lambda s, f: asyncio.create_task(self._handle_signal(s))\n                    )\n        else:\n            for sig in (signal.SIGINT, signal.SIGTERM):\n                signal.signal(\n                    sig, lambda s, f: asyncio.create_task(self._handle_signal(s))\n                )\n\n    async def _handle_signal(self, signum: int) -&gt; None:\n        \"\"\"\n        Handle system signals for graceful shutdown.\n\n        Args:\n            signum: Signal number received\n        \"\"\"\n        signame = (\n            signal.Signals(signum).name if hasattr(signal, \"Signals\") else str(signum)\n        )\n        print(f\"\\nReceived signal {signame}. Shutting down gracefully...\")\n        self._shutdown_event.set()\n        await self.stop()\n        sys.exit(0)\n\n    @property\n    def running(self) -&gt; bool:\n        \"\"\"Check if the client is currently running.\"\"\"\n        return getattr(self, \"_is_running\", False)\n\n    async def stop(self) -&gt; None:\n        \"\"\"\n        Stop the client and clean up resources.\n\n        This method ensures all resources are properly released including\n        browser instances, pages, and the Playwright instance.\n        \"\"\"\n        if not getattr(self, \"_is_running\", False):\n            return\n\n        self._is_running = False\n\n        try:\n            # Close page\n            if hasattr(self, \"_page\") and self._page:\n                try:\n                    await self._page.close()\n                except Exception as e:\n                    await self.emit(\"on_error\", f\"Error closing page: {e}\")\n                finally:\n                    self._page = None\n\n            # Call parent stop\n            await super().stop()\n\n            # Close browser\n            if hasattr(self, \"_browser\") and self._browser:\n                try:\n                    await self._browser.close()\n                except Exception as e:\n                    await self.emit(\"on_error\", f\"Error closing browser: {e}\")\n                finally:\n                    self._browser = None\n\n            # Stop playwright\n            if hasattr(self, \"playwright\") and self.playwright:\n                try:\n                    await self.playwright.stop()\n                except Exception as e:\n                    await self.emit(\"on_error\", f\"Error stopping Playwright: {e}\")\n                finally:\n                    self.playwright = None\n\n        except Exception as e:\n            await self.emit(\"on_error\", f\"Error during cleanup: {e}\")\n        finally:\n            await self.emit(\"on_stop\")\n            self._shutdown_event.set()\n\n    async def start(self) -&gt; None:\n        \"\"\"\n        Start the WhatsApp Web client.\n\n        Initializes all components and begins the main event loop.\n        This method will run until the client is stopped.\n\n        Raises:\n            Exception: If initialization or main loop fails\n        \"\"\"\n        try:\n            await super().start()\n            self.wa_elements = WhatsAppElements(self._page)\n            self.chat_manager = ChatManager(self)\n            self.state_manager = StateManager(self)\n            self._is_running = True\n            await self._main_loop()\n\n        except asyncio.CancelledError:\n            await self.emit(\"on_info\", \"Operation cancelled\")\n            raise\n        except Exception as e:\n            await self.emit(\"on_error\", f\"Error in main loop: {e}\")\n            raise\n        finally:\n            await self.stop()\n\n    async def _main_loop(self) -&gt; None:\n        \"\"\"\n        Initialize and start the main event loop.\n\n        Sets up initial state and begins monitoring WhatsApp Web.\n        \"\"\"\n        if not self._page:\n            await self.emit(\"on_error\", \"Could not initialize page\")\n            return\n\n        await self.emit(\"on_start\")\n\n        try:\n            await self._page.screenshot(path=\"init_main.png\", full_page=True)\n        except Exception as e:\n            await self.emit(\"on_warning\", f\"Could not take initial screenshot: {e}\")\n\n        await self._run_main_loop()\n\n    async def _run_main_loop(self) -&gt; None:\n        \"\"\"\n        Execute the main event loop.\n\n        Continuously monitors WhatsApp Web state and handles state transitions\n        until the client is stopped or encounters unrecoverable errors.\n        \"\"\"\n        state: Optional[State] = None\n\n        while self._is_running and not self._shutdown_event.is_set():\n            try:\n                curr_state = await self.state_manager._get_state()\n                self.current_state = curr_state\n\n                if curr_state is None:\n                    await asyncio.sleep(self.poll_freq)\n                    continue\n\n                if curr_state != state:\n                    await self.state_manager._handle_state_change(curr_state, state)\n                    state = curr_state\n                    self._consecutive_errors = 0  # Reset error counter on successful state change\n                else:\n                    await self.state_manager._handle_same_state(curr_state)\n\n                await self.emit(\"on_tick\")\n                await asyncio.sleep(self.poll_freq)\n\n            except asyncio.CancelledError:\n                await self.emit(\"on_info\", \"Main loop cancelled\")\n                raise\n\n            except Exception as e:\n                self._consecutive_errors += 1\n                await self.emit(\"on_error\", f\"Error in loop iteration: {e}\")\n                await asyncio.sleep(1)\n\n                if self._consecutive_errors &gt; MAX_CONSECUTIVE_ERRORS:\n                    await self.emit(\n                        \"on_warning\",\n                        \"Too many consecutive errors, attempting to reconnect...\",\n                    )\n                    try:\n                        await self.reconnect()\n                        self._consecutive_errors = 0\n                    except Exception as reconnect_error:\n                        await self.emit(\n                            \"on_error\", f\"Reconnection error: {reconnect_error}\"\n                        )\n                        break\n\n    async def wait_until_logged_in(self, timeout: int = DEFAULT_LOGIN_TIMEOUT) -&gt; bool:\n        \"\"\"\n        Wait until the client is logged in.\n\n        Args:\n            timeout: Maximum time to wait in seconds\n\n        Returns:\n            True if logged in within timeout, False otherwise\n        \"\"\"\n        start = time.time()\n        while time.time() - start &lt; timeout:\n            if self.current_state == State.LOGGED_IN:\n                return True\n            await asyncio.sleep(self.poll_freq)\n\n        await self.emit(\"on_error\", \"Login timeout expired\")\n        return False\n\n    # -------------------------------------------------------------------------\n    # Delegated methods to ChatManager\n    # -------------------------------------------------------------------------\n\n    async def close(self) -&gt; None:\n        \"\"\"Close the currently open chat.\"\"\"\n        return await self.chat_manager.close()\n\n    async def open(\n        self, chat_name: str, timeout: int = 10000, open_via_url: bool = False\n    ) -&gt; bool:\n        \"\"\"\n        Open a chat by name.\n\n        Args:\n            chat_name: Name of the chat to open\n            timeout: Maximum wait time in milliseconds\n            open_via_url: Force opening via URL (for phone numbers)\n\n        Returns:\n            True if chat was opened successfully\n        \"\"\"\n        return await self.chat_manager.open(chat_name, timeout, open_via_url=open_via_url)\n\n    async def search_conversations(\n        self, query: str, close: bool = True\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Search for conversations.\n\n        Args:\n            query: Search term\n            close: Close search after completion\n\n        Returns:\n            List of matching conversations\n        \"\"\"\n        return await self.chat_manager.search_conversations(query, close)\n\n    async def collect_messages(self) -&gt; List[Union[Message, FileMessage]]:\n        \"\"\"\n        Collect all visible messages in the current chat.\n\n        Returns:\n            List of Message and FileMessage objects\n        \"\"\"\n        return await self.chat_manager.collect_messages()\n\n    async def download_all_files(self, carpeta: Optional[str] = None) -&gt; List[Path]:\n        \"\"\"\n        Download all files from the current chat.\n\n        Args:\n            carpeta: Optional custom download directory\n\n        Returns:\n            List of paths to downloaded files\n        \"\"\"\n        return await self.chat_manager.download_all_files(carpeta)\n\n    async def download_file_by_index(\n        self, index: int, carpeta: Optional[str] = None\n    ) -&gt; Optional[Path]:\n        \"\"\"\n        Download a specific file by index.\n\n        Args:\n            index: Zero-based file index\n            carpeta: Optional custom download directory\n\n        Returns:\n            Path to downloaded file or None if failed\n        \"\"\"\n        return await self.chat_manager.download_file_by_index(index, carpeta)\n\n    async def send_message(\n        self, chat_query: str, message: str, open_via_url: bool = False\n    ) -&gt; bool:\n        \"\"\"\n        Send a text message.\n\n        Args:\n            chat_query: Chat name or identifier\n            message: Message text to send\n            open_via_url: Open chat via URL before sending\n\n        Returns:\n            True if message was sent successfully\n        \"\"\"\n        return await self.chat_manager.send_message(chat_query, message, open_via_url=open_via_url)\n\n    async def send_file(self, chat_name: str, path: str) -&gt; bool:\n        \"\"\"\n        Send a file attachment.\n\n        Args:\n            chat_name: Name of the chat\n            path: Absolute path to the file\n\n        Returns:\n            True if file was sent successfully\n        \"\"\"\n        return await self.chat_manager.send_file(chat_name, path)\n\n    async def react_to_last_message(self, emoji: str) -&gt; bool:\n        \"\"\"\n        React to the last visible message in the current chat.\n\n        Args:\n            emoji: The emoji to react with (e.g., \"\ud83d\udc4d\", \"\u2764\ufe0f\")\n\n        Returns:\n            True if reaction was successful\n        \"\"\"\n        return await self.chat_manager.react_to_last_message(emoji)\n\n    async def new_group(self, group_name: str, members: List[str]) -&gt; bool:\n        \"\"\"\n        Create a new group.\n\n        Args:\n            group_name: Name for the new group\n            members: List of member names\n\n        Returns:\n            True if group was created successfully\n        \"\"\"\n        return await self.wa_elements.new_group(group_name, members)\n\n    async def add_members_to_group(\n        self, group_name: str, members: List[str]\n    ) -&gt; bool:\n        \"\"\"\n        Add members to an existing group.\n\n        Args:\n            group_name: Name of the group\n            members: List of member names to add\n\n        Returns:\n            True if members were added successfully\n        \"\"\"\n        return await self.wa_elements.add_members_to_group(group_name, members)\n\n    async def del_members_from_group(\n        self, group_name: str, members: List[str]\n    ) -&gt; bool:\n        \"\"\"\n        Remove members from a group.\n\n        Args:\n            group_name: Name of the group\n            members: List of member names to remove\n\n        Returns:\n            True if members were removed successfully\n        \"\"\"\n        return await self.wa_elements.del_member_group(group_name, members)\n</code></pre>"},{"location":"api-reference/#whatsplay.client.Client.running","title":"<code>running</code>  <code>property</code>","text":"<p>Check if the client is currently running.</p>"},{"location":"api-reference/#whatsplay.client.Client.__init__","title":"<code>__init__(user_data_dir=None, headless=False, locale='en-US', auth=None)</code>","text":"<p>Initialize the WhatsApp Web client.</p> <p>Parameters:</p> Name Type Description Default <code>user_data_dir</code> <code>Optional[str]</code> <p>Directory for browser profile data</p> <code>None</code> <code>headless</code> <code>bool</code> <p>Run browser in headless mode</p> <code>False</code> <code>locale</code> <code>str</code> <p>Browser locale setting</p> <code>'en-US'</code> <code>auth</code> <code>Optional[Any]</code> <p>Authentication provider instance</p> <code>None</code> Source code in <code>src/whatsplay/client.py</code> <pre><code>def __init__(\n    self,\n    user_data_dir: Optional[str] = None,\n    headless: bool = False,\n    locale: str = \"en-US\",\n    auth: Optional[Any] = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the WhatsApp Web client.\n\n    Args:\n        user_data_dir: Directory for browser profile data\n        headless: Run browser in headless mode\n        locale: Browser locale setting\n        auth: Authentication provider instance\n    \"\"\"\n    super().__init__(user_data_dir=user_data_dir, headless=headless, auth=auth)\n    self.locale = locale\n    self._cached_chats: set = set()\n    self.poll_freq = DEFAULT_POLL_FREQUENCY\n    self.wa_elements: Optional[WhatsAppElements] = None\n    self.qr_task: Optional[asyncio.Task] = None\n    self.current_state: Optional[State] = None\n    self.unread_messages_sleep = DEFAULT_UNREAD_MESSAGES_SLEEP\n    self._shutdown_event = asyncio.Event()\n    self._consecutive_errors = 0\n    self.last_qr_shown: Optional[bytes] = None\n    self.chat_manager: Optional[ChatManager] = None\n    self.state_manager: Optional[StateManager] = None\n    self._setup_signal_handlers()\n</code></pre>"},{"location":"api-reference/#whatsplay.client.Client.add_members_to_group","title":"<code>add_members_to_group(group_name, members)</code>  <code>async</code>","text":"<p>Add members to an existing group.</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>Name of the group</p> required <code>members</code> <code>List[str]</code> <p>List of member names to add</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if members were added successfully</p> Source code in <code>src/whatsplay/client.py</code> <pre><code>async def add_members_to_group(\n    self, group_name: str, members: List[str]\n) -&gt; bool:\n    \"\"\"\n    Add members to an existing group.\n\n    Args:\n        group_name: Name of the group\n        members: List of member names to add\n\n    Returns:\n        True if members were added successfully\n    \"\"\"\n    return await self.wa_elements.add_members_to_group(group_name, members)\n</code></pre>"},{"location":"api-reference/#whatsplay.client.Client.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close the currently open chat.</p> Source code in <code>src/whatsplay/client.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the currently open chat.\"\"\"\n    return await self.chat_manager.close()\n</code></pre>"},{"location":"api-reference/#whatsplay.client.Client.collect_messages","title":"<code>collect_messages()</code>  <code>async</code>","text":"<p>Collect all visible messages in the current chat.</p> <p>Returns:</p> Type Description <code>List[Union[Message, FileMessage]]</code> <p>List of Message and FileMessage objects</p> Source code in <code>src/whatsplay/client.py</code> <pre><code>async def collect_messages(self) -&gt; List[Union[Message, FileMessage]]:\n    \"\"\"\n    Collect all visible messages in the current chat.\n\n    Returns:\n        List of Message and FileMessage objects\n    \"\"\"\n    return await self.chat_manager.collect_messages()\n</code></pre>"},{"location":"api-reference/#whatsplay.client.Client.del_members_from_group","title":"<code>del_members_from_group(group_name, members)</code>  <code>async</code>","text":"<p>Remove members from a group.</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>Name of the group</p> required <code>members</code> <code>List[str]</code> <p>List of member names to remove</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if members were removed successfully</p> Source code in <code>src/whatsplay/client.py</code> <pre><code>async def del_members_from_group(\n    self, group_name: str, members: List[str]\n) -&gt; bool:\n    \"\"\"\n    Remove members from a group.\n\n    Args:\n        group_name: Name of the group\n        members: List of member names to remove\n\n    Returns:\n        True if members were removed successfully\n    \"\"\"\n    return await self.wa_elements.del_member_group(group_name, members)\n</code></pre>"},{"location":"api-reference/#whatsplay.client.Client.download_all_files","title":"<code>download_all_files(carpeta=None)</code>  <code>async</code>","text":"<p>Download all files from the current chat.</p> <p>Parameters:</p> Name Type Description Default <code>carpeta</code> <code>Optional[str]</code> <p>Optional custom download directory</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Path]</code> <p>List of paths to downloaded files</p> Source code in <code>src/whatsplay/client.py</code> <pre><code>async def download_all_files(self, carpeta: Optional[str] = None) -&gt; List[Path]:\n    \"\"\"\n    Download all files from the current chat.\n\n    Args:\n        carpeta: Optional custom download directory\n\n    Returns:\n        List of paths to downloaded files\n    \"\"\"\n    return await self.chat_manager.download_all_files(carpeta)\n</code></pre>"},{"location":"api-reference/#whatsplay.client.Client.download_file_by_index","title":"<code>download_file_by_index(index, carpeta=None)</code>  <code>async</code>","text":"<p>Download a specific file by index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Zero-based file index</p> required <code>carpeta</code> <code>Optional[str]</code> <p>Optional custom download directory</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Path]</code> <p>Path to downloaded file or None if failed</p> Source code in <code>src/whatsplay/client.py</code> <pre><code>async def download_file_by_index(\n    self, index: int, carpeta: Optional[str] = None\n) -&gt; Optional[Path]:\n    \"\"\"\n    Download a specific file by index.\n\n    Args:\n        index: Zero-based file index\n        carpeta: Optional custom download directory\n\n    Returns:\n        Path to downloaded file or None if failed\n    \"\"\"\n    return await self.chat_manager.download_file_by_index(index, carpeta)\n</code></pre>"},{"location":"api-reference/#whatsplay.client.Client.new_group","title":"<code>new_group(group_name, members)</code>  <code>async</code>","text":"<p>Create a new group.</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>Name for the new group</p> required <code>members</code> <code>List[str]</code> <p>List of member names</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if group was created successfully</p> Source code in <code>src/whatsplay/client.py</code> <pre><code>async def new_group(self, group_name: str, members: List[str]) -&gt; bool:\n    \"\"\"\n    Create a new group.\n\n    Args:\n        group_name: Name for the new group\n        members: List of member names\n\n    Returns:\n        True if group was created successfully\n    \"\"\"\n    return await self.wa_elements.new_group(group_name, members)\n</code></pre>"},{"location":"api-reference/#whatsplay.client.Client.open","title":"<code>open(chat_name, timeout=10000, open_via_url=False)</code>  <code>async</code>","text":"<p>Open a chat by name.</p> <p>Parameters:</p> Name Type Description Default <code>chat_name</code> <code>str</code> <p>Name of the chat to open</p> required <code>timeout</code> <code>int</code> <p>Maximum wait time in milliseconds</p> <code>10000</code> <code>open_via_url</code> <code>bool</code> <p>Force opening via URL (for phone numbers)</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if chat was opened successfully</p> Source code in <code>src/whatsplay/client.py</code> <pre><code>async def open(\n    self, chat_name: str, timeout: int = 10000, open_via_url: bool = False\n) -&gt; bool:\n    \"\"\"\n    Open a chat by name.\n\n    Args:\n        chat_name: Name of the chat to open\n        timeout: Maximum wait time in milliseconds\n        open_via_url: Force opening via URL (for phone numbers)\n\n    Returns:\n        True if chat was opened successfully\n    \"\"\"\n    return await self.chat_manager.open(chat_name, timeout, open_via_url=open_via_url)\n</code></pre>"},{"location":"api-reference/#whatsplay.client.Client.react_to_last_message","title":"<code>react_to_last_message(emoji)</code>  <code>async</code>","text":"<p>React to the last visible message in the current chat.</p> <p>Parameters:</p> Name Type Description Default <code>emoji</code> <code>str</code> <p>The emoji to react with (e.g., \"\ud83d\udc4d\", \"\u2764\ufe0f\")</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if reaction was successful</p> Source code in <code>src/whatsplay/client.py</code> <pre><code>async def react_to_last_message(self, emoji: str) -&gt; bool:\n    \"\"\"\n    React to the last visible message in the current chat.\n\n    Args:\n        emoji: The emoji to react with (e.g., \"\ud83d\udc4d\", \"\u2764\ufe0f\")\n\n    Returns:\n        True if reaction was successful\n    \"\"\"\n    return await self.chat_manager.react_to_last_message(emoji)\n</code></pre>"},{"location":"api-reference/#whatsplay.client.Client.search_conversations","title":"<code>search_conversations(query, close=True)</code>  <code>async</code>","text":"<p>Search for conversations.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Search term</p> required <code>close</code> <code>bool</code> <p>Close search after completion</p> <code>True</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of matching conversations</p> Source code in <code>src/whatsplay/client.py</code> <pre><code>async def search_conversations(\n    self, query: str, close: bool = True\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Search for conversations.\n\n    Args:\n        query: Search term\n        close: Close search after completion\n\n    Returns:\n        List of matching conversations\n    \"\"\"\n    return await self.chat_manager.search_conversations(query, close)\n</code></pre>"},{"location":"api-reference/#whatsplay.client.Client.send_file","title":"<code>send_file(chat_name, path)</code>  <code>async</code>","text":"<p>Send a file attachment.</p> <p>Parameters:</p> Name Type Description Default <code>chat_name</code> <code>str</code> <p>Name of the chat</p> required <code>path</code> <code>str</code> <p>Absolute path to the file</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if file was sent successfully</p> Source code in <code>src/whatsplay/client.py</code> <pre><code>async def send_file(self, chat_name: str, path: str) -&gt; bool:\n    \"\"\"\n    Send a file attachment.\n\n    Args:\n        chat_name: Name of the chat\n        path: Absolute path to the file\n\n    Returns:\n        True if file was sent successfully\n    \"\"\"\n    return await self.chat_manager.send_file(chat_name, path)\n</code></pre>"},{"location":"api-reference/#whatsplay.client.Client.send_message","title":"<code>send_message(chat_query, message, open_via_url=False)</code>  <code>async</code>","text":"<p>Send a text message.</p> <p>Parameters:</p> Name Type Description Default <code>chat_query</code> <code>str</code> <p>Chat name or identifier</p> required <code>message</code> <code>str</code> <p>Message text to send</p> required <code>open_via_url</code> <code>bool</code> <p>Open chat via URL before sending</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if message was sent successfully</p> Source code in <code>src/whatsplay/client.py</code> <pre><code>async def send_message(\n    self, chat_query: str, message: str, open_via_url: bool = False\n) -&gt; bool:\n    \"\"\"\n    Send a text message.\n\n    Args:\n        chat_query: Chat name or identifier\n        message: Message text to send\n        open_via_url: Open chat via URL before sending\n\n    Returns:\n        True if message was sent successfully\n    \"\"\"\n    return await self.chat_manager.send_message(chat_query, message, open_via_url=open_via_url)\n</code></pre>"},{"location":"api-reference/#whatsplay.client.Client.start","title":"<code>start()</code>  <code>async</code>","text":"<p>Start the WhatsApp Web client.</p> <p>Initializes all components and begins the main event loop. This method will run until the client is stopped.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If initialization or main loop fails</p> Source code in <code>src/whatsplay/client.py</code> <pre><code>async def start(self) -&gt; None:\n    \"\"\"\n    Start the WhatsApp Web client.\n\n    Initializes all components and begins the main event loop.\n    This method will run until the client is stopped.\n\n    Raises:\n        Exception: If initialization or main loop fails\n    \"\"\"\n    try:\n        await super().start()\n        self.wa_elements = WhatsAppElements(self._page)\n        self.chat_manager = ChatManager(self)\n        self.state_manager = StateManager(self)\n        self._is_running = True\n        await self._main_loop()\n\n    except asyncio.CancelledError:\n        await self.emit(\"on_info\", \"Operation cancelled\")\n        raise\n    except Exception as e:\n        await self.emit(\"on_error\", f\"Error in main loop: {e}\")\n        raise\n    finally:\n        await self.stop()\n</code></pre>"},{"location":"api-reference/#whatsplay.client.Client.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Stop the client and clean up resources.</p> <p>This method ensures all resources are properly released including browser instances, pages, and the Playwright instance.</p> Source code in <code>src/whatsplay/client.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"\n    Stop the client and clean up resources.\n\n    This method ensures all resources are properly released including\n    browser instances, pages, and the Playwright instance.\n    \"\"\"\n    if not getattr(self, \"_is_running\", False):\n        return\n\n    self._is_running = False\n\n    try:\n        # Close page\n        if hasattr(self, \"_page\") and self._page:\n            try:\n                await self._page.close()\n            except Exception as e:\n                await self.emit(\"on_error\", f\"Error closing page: {e}\")\n            finally:\n                self._page = None\n\n        # Call parent stop\n        await super().stop()\n\n        # Close browser\n        if hasattr(self, \"_browser\") and self._browser:\n            try:\n                await self._browser.close()\n            except Exception as e:\n                await self.emit(\"on_error\", f\"Error closing browser: {e}\")\n            finally:\n                self._browser = None\n\n        # Stop playwright\n        if hasattr(self, \"playwright\") and self.playwright:\n            try:\n                await self.playwright.stop()\n            except Exception as e:\n                await self.emit(\"on_error\", f\"Error stopping Playwright: {e}\")\n            finally:\n                self.playwright = None\n\n    except Exception as e:\n        await self.emit(\"on_error\", f\"Error during cleanup: {e}\")\n    finally:\n        await self.emit(\"on_stop\")\n        self._shutdown_event.set()\n</code></pre>"},{"location":"api-reference/#whatsplay.client.Client.wait_until_logged_in","title":"<code>wait_until_logged_in(timeout=DEFAULT_LOGIN_TIMEOUT)</code>  <code>async</code>","text":"<p>Wait until the client is logged in.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>Maximum time to wait in seconds</p> <code>DEFAULT_LOGIN_TIMEOUT</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if logged in within timeout, False otherwise</p> Source code in <code>src/whatsplay/client.py</code> <pre><code>async def wait_until_logged_in(self, timeout: int = DEFAULT_LOGIN_TIMEOUT) -&gt; bool:\n    \"\"\"\n    Wait until the client is logged in.\n\n    Args:\n        timeout: Maximum time to wait in seconds\n\n    Returns:\n        True if logged in within timeout, False otherwise\n    \"\"\"\n    start = time.time()\n    while time.time() - start &lt; timeout:\n        if self.current_state == State.LOGGED_IN:\n            return True\n        await asyncio.sleep(self.poll_freq)\n\n    await self.emit(\"on_error\", \"Login timeout expired\")\n    return False\n</code></pre>"},{"location":"api-reference/#event-objects","title":"Event Objects","text":"<p>These are the objects passed to your event handlers.</p>"},{"location":"api-reference/#message","title":"Message","text":"<p>The <code>Message</code> object is what you receive in <code>on_message</code> event handlers.</p>"},{"location":"api-reference/#whatsplay.object.message.Message","title":"<code>whatsplay.object.message.Message</code>","text":"Source code in <code>src/whatsplay/object/message.py</code> <pre><code>class Message:\n    def __init__(self, page: Page, sender: str, timestamp: datetime, text: str, container: ElementHandle,\n                 is_outgoing: bool = False, msg_id: str = \"\"):\n        self.page = page\n        self.sender = sender\n        self.timestamp = timestamp\n        self.text = text\n        self.container = container\n        self.is_outgoing = is_outgoing\n        self.msg_id = msg_id\n\n    @classmethod\n    async def from_element(cls, elem: ElementHandle, page: Page) -&gt; Optional[\"Message\"]:\n        try:\n            # 0) Direcci\u00f3n (in/out) e ID si existe\n            classes = (await elem.get_attribute(\"class\")) or \"\"\n            is_outgoing = \"message-out\" in classes  # entrante: message-in\n            msg_id = (await elem.get_attribute(\"data-id\")) or \"\"\n\n            # 1) remitente\n            sender = \"\"\n            remitente_span = await elem.query_selector(\n                'xpath=.//span[@aria-label and substring(@aria-label, string-length(@aria-label))=\":\"]'\n            )\n            if remitente_span:\n                raw_label = await remitente_span.get_attribute(\"aria-label\")\n                if raw_label:\n                    sender = raw_label.rstrip(\":\").strip()\n\n            # 2) hora\n            timestamp = datetime.now()\n            time_span = await elem.query_selector('xpath=.//span[contains(@class,\"x16dsc37\")]')\n            if time_span:\n                hora_text = (await time_span.inner_text()).strip().lower()\n                # Formatos esperados: \"10:30\", \"10:30 am\", \"10:30 p.m.\"\n                match = re.match(r'(\\d{1,2}):(\\d{2})\\s*(a\\.?m\\.?|p\\.?m\\.?|)?', hora_text)\n                if match:\n                    hh = int(match.group(1))\n                    mm = int(match.group(2))\n                    ampm = (match.group(3) or \"\").replace(\".\", \"\")\n\n                    if ampm == 'pm' and hh != 12:\n                        hh += 12\n                    elif ampm == 'am' and hh == 12: # Medianoche\n                        hh = 0\n\n                    ahora = datetime.now()\n                    timestamp = ahora.replace(hour=hh, minute=mm, second=0, microsecond=0)\n\n            # 3) texto\n            texto = \"\"\n            cuerpo_div = await elem.query_selector('xpath=.//div[contains(@class,\"copyable-text\")]/div')\n            if cuerpo_div:\n                raw_inner = await cuerpo_div.inner_text()\n                if raw_inner:\n                    lineas = raw_inner.split(\"\\n\")\n                    if len(lineas) &gt; 1 and (lineas[0].strip().startswith(sender) or \":\" in lineas[0]):\n                        texto = \"\\n\".join(lineas[1:]).strip()\n                    else:\n                        texto = raw_inner.strip()\n\n            return cls(\n                page=page, sender=sender, timestamp=timestamp, text=texto, container=elem,\n                is_outgoing=is_outgoing, msg_id=msg_id\n            )\n        except Exception:\n            return None\n\n    async def react(self, emoji: str):\n        \"\"\"\n        Reacts to this message with the given emoji, following the user-verified workflow.\n        \"\"\"\n\n        try:\n            # 1. Hover over the message to make the action bar appear.\n            await self.container.hover()\n\n            # Take screenshot after hover\n            await self.container.screenshot(path=\"after_hover.png\")\n            print(\"self.container: \", self.container)\n            await asyncio.sleep(1.5)\n            input(\"presiona enter para continuar\")\n\n            # 2. The user confirmed a button with aria-label=\"Reaccionar\" appears first.\n            # We wait for it to ensure the hover menu is open.\n            # This is likely the default reaction button, but it makes the '+' button visible.\n            reaction_bar = self.page.locator('[aria-label=\"Reaccionar\"]')\n            if not reaction_bar:\n                print(\"Error: No se encontr\u00f3 el bot\u00f3n '[aria-label=\\\"Reaccionar\\\"]'.\")\n                return None\n            await reaction_bar.click()\n\n            # 3. The user confirmed they must then click a button with aria-label=\"M\u00e1s reacciones\" to open the picker.\n            more_reactions_button_handle = self.page.locator('[aria-label=\"M\u00e1s reacciones\"]')\n            if not more_reactions_button_handle:\n                print(\"Error: No se encontr\u00f3 el bot\u00f3n '[aria-label=\\\"M\u00e1s reacciones\\\"]'.\")\n                return None\n\n            await more_reactions_button_handle.click()\n\n            # 4. The emoji picker appears on the main page. We now use the main page object.\n            # We also use the correct selector for emojis, which is their aria-label.\n\n            # The selector finds the picker and then the specific emoji inside it.\n            emoji_in_picker = self.page.locator(f'[data-emoji=\"{emoji}\"]')\n\n            # 5. Wait for the emoji to be visible and click it.\n            await emoji_in_picker.wait_for(state=\"visible\", timeout=5000)\n            await emoji_in_picker.click()\n\n            print(f\"Successfully reacted with '{emoji}'\")\n\n        except Exception as e:\n            print(f\"An error occurred while reacting to message {self.msg_id}: {e}\")\n</code></pre>"},{"location":"api-reference/#whatsplay.object.message.Message.react","title":"<code>react(emoji)</code>  <code>async</code>","text":"<p>Reacts to this message with the given emoji, following the user-verified workflow.</p> Source code in <code>src/whatsplay/object/message.py</code> <pre><code>async def react(self, emoji: str):\n    \"\"\"\n    Reacts to this message with the given emoji, following the user-verified workflow.\n    \"\"\"\n\n    try:\n        # 1. Hover over the message to make the action bar appear.\n        await self.container.hover()\n\n        # Take screenshot after hover\n        await self.container.screenshot(path=\"after_hover.png\")\n        print(\"self.container: \", self.container)\n        await asyncio.sleep(1.5)\n        input(\"presiona enter para continuar\")\n\n        # 2. The user confirmed a button with aria-label=\"Reaccionar\" appears first.\n        # We wait for it to ensure the hover menu is open.\n        # This is likely the default reaction button, but it makes the '+' button visible.\n        reaction_bar = self.page.locator('[aria-label=\"Reaccionar\"]')\n        if not reaction_bar:\n            print(\"Error: No se encontr\u00f3 el bot\u00f3n '[aria-label=\\\"Reaccionar\\\"]'.\")\n            return None\n        await reaction_bar.click()\n\n        # 3. The user confirmed they must then click a button with aria-label=\"M\u00e1s reacciones\" to open the picker.\n        more_reactions_button_handle = self.page.locator('[aria-label=\"M\u00e1s reacciones\"]')\n        if not more_reactions_button_handle:\n            print(\"Error: No se encontr\u00f3 el bot\u00f3n '[aria-label=\\\"M\u00e1s reacciones\\\"]'.\")\n            return None\n\n        await more_reactions_button_handle.click()\n\n        # 4. The emoji picker appears on the main page. We now use the main page object.\n        # We also use the correct selector for emojis, which is their aria-label.\n\n        # The selector finds the picker and then the specific emoji inside it.\n        emoji_in_picker = self.page.locator(f'[data-emoji=\"{emoji}\"]')\n\n        # 5. Wait for the emoji to be visible and click it.\n        await emoji_in_picker.wait_for(state=\"visible\", timeout=5000)\n        await emoji_in_picker.click()\n\n        print(f\"Successfully reacted with '{emoji}'\")\n\n    except Exception as e:\n        print(f\"An error occurred while reacting to message {self.msg_id}: {e}\")\n</code></pre>"},{"location":"api-reference/#managers","title":"Managers","text":"<p>Internal managers that handle different aspects of the client's functionality.</p>"},{"location":"api-reference/#chat-manager","title":"Chat Manager","text":"<p>Responsible for finding and managing chats.</p>"},{"location":"api-reference/#whatsplay.chat_manager.ChatManager","title":"<code>whatsplay.chat_manager.ChatManager</code>","text":"<p>Manages chat operations for WhatsApp Web.</p> <p>This class handles all chat-related operations including: - Opening and closing chats - Searching for conversations - Sending messages and files - Detecting unread chats - Downloading files from chats - Managing group operations</p> <p>Attributes:</p> Name Type Description <code>client</code> <p>Reference to the main WhatsApp client</p> <code>_page</code> <p>Playwright page object for browser interactions</p> <code>wa_elements</code> <p>WhatsApp Web elements helper</p> Source code in <code>src/whatsplay/chat_manager.py</code> <pre><code>class ChatManager:\n    \"\"\"\n    Manages chat operations for WhatsApp Web.\n\n    This class handles all chat-related operations including:\n    - Opening and closing chats\n    - Searching for conversations\n    - Sending messages and files\n    - Detecting unread chats\n    - Downloading files from chats\n    - Managing group operations\n\n    Attributes:\n        client: Reference to the main WhatsApp client\n        _page: Playwright page object for browser interactions\n        wa_elements: WhatsApp Web elements helper\n    \"\"\"\n\n    def __init__(self, client: \"Client\") -&gt; None:\n        \"\"\"\n        Initialize ChatManager with client reference.\n\n        Args:\n            client: The main WhatsApp client instance\n        \"\"\"\n        self.client = client\n        self._page = client._page\n        self.wa_elements = client.wa_elements\n\n    async def _check_unread_chats(self, debug: bool = True) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Detect all unread chats in the sidebar.\n\n        This method scans the chat list to identify unread messages using multiple\n        heuristics including aria-labels, badges, and font weight detection.\n\n        Args:\n            debug: If True, prints debug information during execution\n\n        Returns:\n            List of dictionaries containing unread chat information\n\n        Note:\n            The method uses multiple detection strategies:\n            1. aria-label matching for 'unread' or 'mensaje(s) no le\u00eddo'\n            2. Explicit unread badge detection\n            3. Bold font weight detection on chat titles\n        \"\"\"\n        unread_chats: List[Dict[str, Any]] = []\n        await self.close()  # Ensure no chat is currently open\n\n        def log(msg: str) -&gt; None:\n            \"\"\"Log debug messages if debug mode is enabled.\"\"\"\n            if debug:\n                print(msg)\n\n        async def _wait_for_grid() -&gt; None:\n            \"\"\"Wait for the chat grid to be present and hydrated.\"\"\"\n            try:\n                await self._page.locator(loc.CHAT_LIST_GRID).wait_for(timeout=15000)\n            except Exception:\n                await self._page.wait_for_timeout(1000)\n\n        async def _get_scroller_handle():\n            \"\"\"\n            Get the ElementHandle of the actual scrolling container.\n\n            Returns:\n                ElementHandle for the virtualizable scrolling container\n            \"\"\"\n            grid = self._page.locator(loc.CHAT_LIST_GRID)\n            grid_h = await grid.element_handle()\n\n            if not grid_h:\n                return await self._page.locator(\"#pane-side\").element_handle()\n\n            return await grid_h.evaluate_handle(\n                \"\"\"(el) =&gt; {\n                    let cur = el;\n                    while (cur &amp;&amp; cur !== document.body) {\n                        const s = getComputedStyle(cur);\n                        if ((s.overflowY === 'auto' || s.overflowY === 'scroll') &amp;&amp;\n                            cur.clientHeight &lt; cur.scrollHeight) return cur;\n                        cur = cur.parentElement;\n                    }\n                    return document.querySelector('#pane-side');\n                }\"\"\"\n            )\n\n        async def _is_row_unread(row_loc) -&gt; bool:\n            \"\"\"\n            Determine if a chat row represents an unread conversation.\n\n            Uses multiple detection strategies:\n            1. aria-label with 'unread' or 'mensaje(s) no le\u00eddo'\n            2. Explicit unread badge\n            3. Bold font weight on title (&gt;= 600)\n\n            Args:\n                row_loc: Locator for the chat row\n\n            Returns:\n                True if the chat is unread, False otherwise\n            \"\"\"\n            try:\n                # Strategy 1: Check aria-label for unread indicators\n                has_aria = await row_loc.locator(\"[aria-label]\").evaluate_all(\n                    \"(els, rx) =&gt; els.some(el =&gt; (el.getAttribute('aria-label')||'').match(new RegExp(rx,'i')))\",\n                    UNREAD_ARIA_PATTERN,\n                )\n                if has_aria:\n                    return True\n\n                # Strategy 2: Check for explicit unread badge\n                try:\n                    if await row_loc.locator(f\"xpath={loc.UNREAD_BADGE}\").count() &gt; 0:\n                        return True\n                except Exception:\n                    pass\n\n                # Strategy 3: Check for bold font weight on title\n                title = row_loc.locator(f\"xpath={loc.SPAN_TITLE}\")\n                if await title.count() == 0:\n                    return False\n\n                is_bold = await title.evaluate(\n                    \"\"\"(el) =&gt; {\n                        const w = getComputedStyle(el).fontWeight;\n                        const n = parseInt(w, 10);\n                        return isNaN(n) ? /bold/i.test(w) : n &gt;= 600;\n                    }\"\"\"\n                )\n                return bool(is_bold)\n\n            except Exception:\n                return False\n\n        async def _parse_row(row_loc):\n            \"\"\"\n            Parse a chat row into structured data.\n\n            Args:\n                row_loc: Locator for the chat row\n\n            Returns:\n                Dictionary with chat information or None if parsing fails\n            \"\"\"\n            handle = await row_loc.element_handle()\n            if not handle:\n                return None\n            return await self._parse_search_result(handle, \"CHATS\")\n\n        try:\n            # Step 0: Wait for UI to be ready\n            await _wait_for_grid()\n\n            # Step 1: Debug initial state\n            try:\n                total_rows_now = await self._page.locator(\n                    f\"xpath={loc.CHAT_LIST_ROWS}\"\n                ).count()\n                log(f\"DEBUG: Initially visible rows: {total_rows_now}\")\n\n                if total_rows_now &lt;= MIN_VISIBLE_CHATS_THRESHOLD:\n                    await self._page.locator(loc.ALL_CHATS_BUTTON).click()\n                    log(\"DEBUG: Few chats visible, clicking 'All' button\")\n                    log(\"DEBUG: Taking screenshot of low chat count state\")\n                    await self._page.screenshot(path=\"pocos_chats_visibles.png\")\n\n            except Exception:\n                log(\"DEBUG: Could not count initial rows\")\n\n            # Step 2: Get correct scroller for virtualized list\n            scroller_h = await _get_scroller_handle()\n\n            # Step 3: Sweep visible rows\n            async def sweep(tag: str) -&gt; None:\n                \"\"\"\n                Scan visible chat rows for unread messages.\n\n                Args:\n                    tag: Label for this sweep operation (for debugging)\n                \"\"\"\n                nonlocal unread_chats\n                rows = self._page.locator(f\"xpath={loc.CHAT_LIST_ROWS}\")\n                count = await rows.count()\n                log(f\"DEBUG: {tag}: Currently visible rows: {count}\")\n\n                for i in range(count):\n                    row = rows.nth(i)\n                    try:\n                        if await _is_row_unread(row):\n                            chat = await _parse_row(row)\n                            if chat:\n                                unread_chats.append(chat)\n                                log(f\"\u2713 Unread ({tag}): {chat.get('name', 'No name')}\")\n                    except Exception as e:\n                        log(f\"DEBUG: Error evaluating row {i} ({tag}): {e}\")\n\n            # Step 4: Initial sweep\n            await sweep(\"initial\")\n\n            # Step 5: Deduplication\n            def _get_chat_key(ch: Dict[str, Any]) -&gt; tuple:\n                \"\"\"Generate a unique key for a chat to enable deduplication.\"\"\"\n                return ch.get(\"id\") or (\n                    ch.get(\"name\"),\n                    ch.get(\"last_message\"),\n                    ch.get(\"last_activity\"),\n                )\n\n            seen = set()\n            dedup = []\n            for ch in unread_chats:\n                k = _get_chat_key(ch)\n                if k in seen:\n                    continue\n                seen.add(k)\n                dedup.append(ch)\n            unread_chats = dedup\n\n        except Exception as e:\n            await self.client.emit(\"on_warning\", f\"Error detecting unread chats: {e}\")\n            log(f\"DEBUG: General error: {e}\")\n\n        # Step 6: Final summary\n        log(\"\\nDEBUG: ===== SUMMARY =====\")\n        log(f\"Total unread chats found: {len(unread_chats)}\")\n        for i, chat in enumerate(unread_chats, 1):\n            log(f\"  {i}. {chat.get('name', 'No name')}\")\n\n        return unread_chats\n\n    async def _parse_search_result(\n        self, element, result_type: str = \"CHATS\"\n    ) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"\n        Parse a search result element into structured data.\n\n        Args:\n            element: ElementHandle of the search result row\n            result_type: Type of result (default: \"CHATS\")\n\n        Returns:\n            Dictionary containing parsed chat information or None if parsing fails\n\n        Note:\n            Handles two main layouts:\n            - 3 components: Group chats (group name, title, last message)\n            - 2 components: Direct chats (title, last message)\n        \"\"\"\n        try:\n            components = await element.query_selector_all(\n                \"xpath=.//div[@role='gridcell' and @aria-colindex='2']/parent::div/div\"\n            )\n            count = len(components)\n\n            # Extract unread count\n            unread_el = await element.query_selector(\n                f\"xpath={loc.SEARCH_ITEM_UNREAD_MESSAGES}\"\n            )\n            unread_count = await unread_el.inner_text() if unread_el else \"0\"\n\n            # Check for audio message\n            mic_span = await components[1].query_selector(\n                'xpath=.//span[@data-icon=\"mic\"]'\n            )\n\n            if count == 3:\n                # Group chat layout\n                span_title_0 = await components[0].query_selector(\n                    f\"xpath={loc.SPAN_TITLE}\"\n                )\n                group_title = (\n                    await span_title_0.get_attribute(\"title\") if span_title_0 else \"\"\n                )\n\n                datetime_children = await components[0].query_selector_all(\"xpath=./*\")\n                datetime_text = (\n                    await datetime_children[1].text_content()\n                    if len(datetime_children) &gt; 1\n                    else \"\"\n                )\n\n                span_title_1 = await components[1].query_selector(\n                    f\"xpath={loc.SPAN_TITLE}\"\n                )\n                title = (\n                    await span_title_1.get_attribute(\"title\") if span_title_1 else \"\"\n                )\n\n                info_text = (await components[2].text_content()) or \"\"\n                info_text = info_text.replace(\"\\n\", \"\")\n\n                # Skip invalid states\n                if any(x in info_text for x in [\"loading\", \"status-\", \"typing\"]):\n                    return None\n\n                return {\n                    \"type\": result_type,\n                    \"group\": group_title,\n                    \"name\": title,\n                    \"last_activity\": datetime_text,\n                    \"last_message\": info_text,\n                    \"last_message_type\": \"audio\" if mic_span else \"text\",\n                    \"unread_count\": unread_count,\n                    \"element\": element,\n                }\n\n            elif count == 2:\n                # Direct chat layout\n                span_title_0 = await components[0].query_selector(\n                    f\"xpath={loc.SPAN_TITLE}\"\n                )\n                title = (\n                    await span_title_0.get_attribute(\"title\") if span_title_0 else \"\"\n                )\n\n                datetime_children = await components[0].query_selector_all(\"xpath=./*\")\n                datetime_text = (\n                    await datetime_children[1].text_content()\n                    if len(datetime_children) &gt; 1\n                    else \"\"\n                )\n\n                info_children = await components[1].query_selector_all(\"xpath=./*\")\n                info_text = (\n                    await info_children[0].text_content()\n                    if len(info_children) &gt; 0\n                    else \"\"\n                ) or \"\"\n                info_text = info_text.replace(\"\\n\", \"\")\n\n                # Skip invalid states\n                if any(x in info_text for x in [\"loading\", \"status-\", \"typing\"]):\n                    return None\n\n                return {\n                    \"type\": result_type,\n                    \"name\": title,\n                    \"last_activity\": datetime_text,\n                    \"last_message\": info_text,\n                    \"last_message_type\": \"audio\" if mic_span else \"text\",\n                    \"unread_count\": unread_count,\n                    \"element\": element,\n                    \"group\": None,\n                }\n\n            return None\n\n        except Exception as e:\n            print(f\"Error parsing result: {e}\")\n            return None\n\n    async def close(self) -&gt; None:\n        \"\"\"\n        Close the current chat or view by pressing Escape.\n\n        This method safely closes any open chat window by simulating\n        the Escape key press.\n        \"\"\"\n        if self._page:\n            try:\n                await self._page.keyboard.press(\"Escape\")\n                await asyncio.sleep(0.5) # Allow UI to react\n            except Exception as e:\n                await self.client.emit(\n                    \"on_warning\", f\"Error trying to close chat with Escape: {e}\"\n                )\n\n    async def open(\n        self, chat_name: str, timeout: int = DEFAULT_WAIT_TIMEOUT, open_via_url: bool = False\n    ) -&gt; bool:\n        \"\"\"\n        Open a chat by name.\n\n        Args:\n            chat_name: Name of the chat to open\n            timeout: Maximum time to wait in milliseconds\n            open_via_url: If True, forces opening via URL (for phone numbers)\n\n        Returns:\n            True if chat was opened successfully, False otherwise\n        \"\"\"\n        return await self.wa_elements.open(chat_name, timeout, open_via_url=open_via_url)\n\n    async def search_conversations(\n        self, query: str, close: bool = True\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Search for conversations by term.\n\n        Args:\n            query: Search term\n            close: If True, closes the search after completion\n\n        Returns:\n            List of matching conversations\n        \"\"\"\n        if not await self.client.wait_until_logged_in():\n            return []\n        try:\n            return await self.wa_elements.search_chats(query, close)\n        except Exception as e:\n            await self.client.emit(\"on_error\", f\"Search error: {e}\")\n            return []\n\n    async def collect_messages(self) -&gt; List[Union[Message, FileMessage]]:\n        \"\"\"\n        Collect all currently visible messages in the active chat.\n\n        Scans all visible message containers (message-in/message-out) and\n        returns a list of Message or FileMessage instances.\n\n        Returns:\n            List of Message or FileMessage objects\n        \"\"\"\n        results: List[Union[Message, FileMessage]] = []\n        msg_elements = await self._page.query_selector_all(\n            'div[class*=\"message-in\"], div[class*=\"message-out\"]'\n        )\n\n        for elem in msg_elements:\n            # Try to parse as FileMessage first\n            file_msg = await FileMessage.from_element(elem, self._page)\n            if file_msg:\n                results.append(file_msg)\n                continue\n\n            # Fall back to regular Message\n            simple_msg = await Message.from_element(elem, self._page)\n            if simple_msg:\n                results.append(simple_msg)\n\n        return results\n\n    async def react_to_last_message(self, emoji: str) -&gt; bool:\n        \"\"\"\n        React to the last visible message in the current chat.\n\n        Args:\n            emoji: The emoji to react with (e.g., \"\ud83d\udc4d\", \"\u2764\ufe0f\")\n\n        Returns:\n            True if reaction was successful, False otherwise\n        \"\"\"\n        try:\n            messages = await self.collect_messages()\n            if not messages:\n                await self.client.emit(\"on_warning\", \"No messages found to react to.\")\n                return False\n\n            last_message = messages[-1]\n            await last_message.react(emoji)\n            return True\n        except Exception as e:\n            await self.client.emit(\"on_error\", f\"Error reacting to last message: {e}\")\n            return False\n\n    async def download_all_files(\n        self, carpeta: Optional[str] = None\n    ) -&gt; List[Path]:\n        \"\"\"\n        Download all file attachments from the current chat.\n\n        Args:\n            carpeta: Optional custom download directory path\n\n        Returns:\n            List of Path objects where files were saved\n        \"\"\"\n        if not await self.client.wait_until_logged_in():\n            return []\n\n        downloads_dir = (\n            Path(carpeta) if carpeta else DEFAULT_DOWNLOADS_DIR\n        )\n\n        saved_files: List[Path] = []\n        messages = await self.collect_messages()\n\n        for msg in messages:\n            if isinstance(msg, FileMessage):\n                file_path = await msg.download(self._page, downloads_dir)\n                if file_path:\n                    saved_files.append(file_path)\n\n        return saved_files\n\n    async def download_file_by_index(\n        self, index: int, carpeta: Optional[str] = None\n    ) -&gt; Optional[Path]:\n        \"\"\"\n        Download a specific file by its index in the message list.\n\n        Args:\n            index: Zero-based index of the file to download\n            carpeta: Optional custom download directory path\n\n        Returns:\n            Path to the downloaded file or None if failed\n        \"\"\"\n        if not await self.client.wait_until_logged_in():\n            return None\n\n        downloads_dir = (\n            Path(carpeta) if carpeta else DEFAULT_DOWNLOADS_DIR\n        )\n\n        messages = await self.collect_messages()\n        files = [m for m in messages if isinstance(m, FileMessage)]\n\n        if index &lt; 0 or index &gt;= len(files):\n            return None\n\n        return await files[index].download(self._page, downloads_dir)\n\n    async def send_message(\n        self, chat_query: str, message: str, open_via_url: bool = False\n    ) -&gt; bool:\n        \"\"\"\n        Send a text message to a chat.\n\n        Args:\n            chat_query: Name or identifier of the chat\n            message: Text message to send\n            open_via_url: If True, opens the chat via URL before sending\n\n        Returns:\n            True if message was sent successfully, False otherwise\n        \"\"\"\n        print(\"Sending message...\")\n        if not await self.client.wait_until_logged_in():\n            return False\n\n        try:\n            opened = await self.open(chat_query, open_via_url=open_via_url)\n            if not opened:\n                await self.client.emit(\n                    \"on_error\", f\"Could not open chat: {chat_query}\"\n                )\n                return False\n            print(f\"\u2713 Chat '{chat_query}' opened, sending message\")\n\n            await self._page.wait_for_selector(loc.CHAT_INPUT_BOX, timeout=DEFAULT_WAIT_TIMEOUT)\n            input_box = await self._page.wait_for_selector(\n                loc.CHAT_INPUT_BOX, timeout=DEFAULT_WAIT_TIMEOUT\n            )\n\n            if not input_box:\n                await self.client.emit(\n                    \"on_error\",\n                    \"Could not find text input box for sending message\",\n                )\n                return False\n\n            await input_box.click()\n            await input_box.fill(message)\n            await self._page.keyboard.press(\"Enter\")\n\n            # Add a short delay to allow the message to be processed by WhatsApp Web UI\n            await asyncio.sleep(2)\n\n            return True\n\n        except Exception as e:\n            await self._page.screenshot(path=\"send_message_error.png\")\n            await self.client.emit(\"on_error\", f\"Error sending message: {e}\")\n            return False\n        finally:\n            await self.close()\n\n    async def send_file(self, chat_name: str, path: str) -&gt; bool:\n        \"\"\"\n        Send a file attachment to a chat.\n\n        Args:\n            chat_name: Name of the chat to send the file to\n            path: Absolute path to the file to send\n\n        Returns:\n            True if file was sent successfully, False otherwise\n        \"\"\"\n        try:\n            if not os.path.isfile(path):\n                msg = f\"File does not exist: {path}\"\n                await self.client.emit(\"on_error\", msg)\n                return False\n\n            if not await self.client.wait_until_logged_in():\n                msg = \"Could not log in\"\n                await self.client.emit(\"on_error\", msg)\n                return False\n\n            if not await self.open(chat_name):\n                msg = f\"Could not open chat: {chat_name}\"\n                await self.client.emit(\"on_error\", msg)\n                return False\n\n            await self._page.wait_for_selector(loc.CHAT_INPUT_BOX, timeout=DEFAULT_WAIT_TIMEOUT)\n\n            attach_btn = await self._page.wait_for_selector(\n                loc.ATTACH_BUTTON, timeout=5000\n            )\n            await attach_btn.click()\n\n            input_files = await self._page.query_selector_all(loc.FILE_INPUT)\n            if not input_files:\n                msg = \"Could not find input[type='file']\"\n                await self.client.emit(\"on_error\", msg)\n                return False\n\n            await input_files[0].set_input_files(path)\n            await asyncio.sleep(1)\n\n            send_btn = await self._page.wait_for_selector(\n                loc.SEND_BUTTON, timeout=DEFAULT_WAIT_TIMEOUT\n            )\n            await send_btn.click()\n\n            return True\n\n        except Exception as e:\n            msg = f\"Unexpected error in send_file: {str(e)}\"\n            await self.client.emit(\"on_error\", msg)\n            await self._page.screenshot(path=\"send_file_error.png\")\n            return False\n        finally:\n            await self.close()\n\n    async def new_group(self, group_name: str, members: List[str]) -&gt; bool:\n        \"\"\"\n        Create a new WhatsApp group.\n\n        Args:\n            group_name: Name for the new group\n            members: List of member names to add to the group\n\n        Returns:\n            True if group was created successfully, False otherwise\n        \"\"\"\n        return await self.wa_elements.new_group(group_name, members)\n\n    async def add_members_to_group(\n        self, group_name: str, members: List[str]\n    ) -&gt; bool:\n        \"\"\"\n        Add members to an existing group.\n\n        Args:\n            group_name: Name of the group\n            members: List of member names to add\n\n        Returns:\n            True if members were added successfully, False otherwise\n        \"\"\"\n        try:\n            if not await self.open(group_name):\n                await self.client.emit(\n                    \"on_error\", f\"Could not open group '{group_name}'\"\n                )\n                return False\n\n            success = await self.wa_elements.add_members_to_group(group_name, members)\n            return success\n\n        except Exception as e:\n            await self.client.emit(\n                \"on_error\", f\"Error adding members to group '{group_name}': {e}\"\n            )\n            return False\n</code></pre>"},{"location":"api-reference/#whatsplay.chat_manager.ChatManager.__init__","title":"<code>__init__(client)</code>","text":"<p>Initialize ChatManager with client reference.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>The main WhatsApp client instance</p> required Source code in <code>src/whatsplay/chat_manager.py</code> <pre><code>def __init__(self, client: \"Client\") -&gt; None:\n    \"\"\"\n    Initialize ChatManager with client reference.\n\n    Args:\n        client: The main WhatsApp client instance\n    \"\"\"\n    self.client = client\n    self._page = client._page\n    self.wa_elements = client.wa_elements\n</code></pre>"},{"location":"api-reference/#whatsplay.chat_manager.ChatManager.add_members_to_group","title":"<code>add_members_to_group(group_name, members)</code>  <code>async</code>","text":"<p>Add members to an existing group.</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>Name of the group</p> required <code>members</code> <code>List[str]</code> <p>List of member names to add</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if members were added successfully, False otherwise</p> Source code in <code>src/whatsplay/chat_manager.py</code> <pre><code>async def add_members_to_group(\n    self, group_name: str, members: List[str]\n) -&gt; bool:\n    \"\"\"\n    Add members to an existing group.\n\n    Args:\n        group_name: Name of the group\n        members: List of member names to add\n\n    Returns:\n        True if members were added successfully, False otherwise\n    \"\"\"\n    try:\n        if not await self.open(group_name):\n            await self.client.emit(\n                \"on_error\", f\"Could not open group '{group_name}'\"\n            )\n            return False\n\n        success = await self.wa_elements.add_members_to_group(group_name, members)\n        return success\n\n    except Exception as e:\n        await self.client.emit(\n            \"on_error\", f\"Error adding members to group '{group_name}': {e}\"\n        )\n        return False\n</code></pre>"},{"location":"api-reference/#whatsplay.chat_manager.ChatManager.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close the current chat or view by pressing Escape.</p> <p>This method safely closes any open chat window by simulating the Escape key press.</p> Source code in <code>src/whatsplay/chat_manager.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"\n    Close the current chat or view by pressing Escape.\n\n    This method safely closes any open chat window by simulating\n    the Escape key press.\n    \"\"\"\n    if self._page:\n        try:\n            await self._page.keyboard.press(\"Escape\")\n            await asyncio.sleep(0.5) # Allow UI to react\n        except Exception as e:\n            await self.client.emit(\n                \"on_warning\", f\"Error trying to close chat with Escape: {e}\"\n            )\n</code></pre>"},{"location":"api-reference/#whatsplay.chat_manager.ChatManager.collect_messages","title":"<code>collect_messages()</code>  <code>async</code>","text":"<p>Collect all currently visible messages in the active chat.</p> <p>Scans all visible message containers (message-in/message-out) and returns a list of Message or FileMessage instances.</p> <p>Returns:</p> Type Description <code>List[Union[Message, FileMessage]]</code> <p>List of Message or FileMessage objects</p> Source code in <code>src/whatsplay/chat_manager.py</code> <pre><code>async def collect_messages(self) -&gt; List[Union[Message, FileMessage]]:\n    \"\"\"\n    Collect all currently visible messages in the active chat.\n\n    Scans all visible message containers (message-in/message-out) and\n    returns a list of Message or FileMessage instances.\n\n    Returns:\n        List of Message or FileMessage objects\n    \"\"\"\n    results: List[Union[Message, FileMessage]] = []\n    msg_elements = await self._page.query_selector_all(\n        'div[class*=\"message-in\"], div[class*=\"message-out\"]'\n    )\n\n    for elem in msg_elements:\n        # Try to parse as FileMessage first\n        file_msg = await FileMessage.from_element(elem, self._page)\n        if file_msg:\n            results.append(file_msg)\n            continue\n\n        # Fall back to regular Message\n        simple_msg = await Message.from_element(elem, self._page)\n        if simple_msg:\n            results.append(simple_msg)\n\n    return results\n</code></pre>"},{"location":"api-reference/#whatsplay.chat_manager.ChatManager.download_all_files","title":"<code>download_all_files(carpeta=None)</code>  <code>async</code>","text":"<p>Download all file attachments from the current chat.</p> <p>Parameters:</p> Name Type Description Default <code>carpeta</code> <code>Optional[str]</code> <p>Optional custom download directory path</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Path]</code> <p>List of Path objects where files were saved</p> Source code in <code>src/whatsplay/chat_manager.py</code> <pre><code>async def download_all_files(\n    self, carpeta: Optional[str] = None\n) -&gt; List[Path]:\n    \"\"\"\n    Download all file attachments from the current chat.\n\n    Args:\n        carpeta: Optional custom download directory path\n\n    Returns:\n        List of Path objects where files were saved\n    \"\"\"\n    if not await self.client.wait_until_logged_in():\n        return []\n\n    downloads_dir = (\n        Path(carpeta) if carpeta else DEFAULT_DOWNLOADS_DIR\n    )\n\n    saved_files: List[Path] = []\n    messages = await self.collect_messages()\n\n    for msg in messages:\n        if isinstance(msg, FileMessage):\n            file_path = await msg.download(self._page, downloads_dir)\n            if file_path:\n                saved_files.append(file_path)\n\n    return saved_files\n</code></pre>"},{"location":"api-reference/#whatsplay.chat_manager.ChatManager.download_file_by_index","title":"<code>download_file_by_index(index, carpeta=None)</code>  <code>async</code>","text":"<p>Download a specific file by its index in the message list.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Zero-based index of the file to download</p> required <code>carpeta</code> <code>Optional[str]</code> <p>Optional custom download directory path</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Path]</code> <p>Path to the downloaded file or None if failed</p> Source code in <code>src/whatsplay/chat_manager.py</code> <pre><code>async def download_file_by_index(\n    self, index: int, carpeta: Optional[str] = None\n) -&gt; Optional[Path]:\n    \"\"\"\n    Download a specific file by its index in the message list.\n\n    Args:\n        index: Zero-based index of the file to download\n        carpeta: Optional custom download directory path\n\n    Returns:\n        Path to the downloaded file or None if failed\n    \"\"\"\n    if not await self.client.wait_until_logged_in():\n        return None\n\n    downloads_dir = (\n        Path(carpeta) if carpeta else DEFAULT_DOWNLOADS_DIR\n    )\n\n    messages = await self.collect_messages()\n    files = [m for m in messages if isinstance(m, FileMessage)]\n\n    if index &lt; 0 or index &gt;= len(files):\n        return None\n\n    return await files[index].download(self._page, downloads_dir)\n</code></pre>"},{"location":"api-reference/#whatsplay.chat_manager.ChatManager.new_group","title":"<code>new_group(group_name, members)</code>  <code>async</code>","text":"<p>Create a new WhatsApp group.</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>Name for the new group</p> required <code>members</code> <code>List[str]</code> <p>List of member names to add to the group</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if group was created successfully, False otherwise</p> Source code in <code>src/whatsplay/chat_manager.py</code> <pre><code>async def new_group(self, group_name: str, members: List[str]) -&gt; bool:\n    \"\"\"\n    Create a new WhatsApp group.\n\n    Args:\n        group_name: Name for the new group\n        members: List of member names to add to the group\n\n    Returns:\n        True if group was created successfully, False otherwise\n    \"\"\"\n    return await self.wa_elements.new_group(group_name, members)\n</code></pre>"},{"location":"api-reference/#whatsplay.chat_manager.ChatManager.open","title":"<code>open(chat_name, timeout=DEFAULT_WAIT_TIMEOUT, open_via_url=False)</code>  <code>async</code>","text":"<p>Open a chat by name.</p> <p>Parameters:</p> Name Type Description Default <code>chat_name</code> <code>str</code> <p>Name of the chat to open</p> required <code>timeout</code> <code>int</code> <p>Maximum time to wait in milliseconds</p> <code>DEFAULT_WAIT_TIMEOUT</code> <code>open_via_url</code> <code>bool</code> <p>If True, forces opening via URL (for phone numbers)</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if chat was opened successfully, False otherwise</p> Source code in <code>src/whatsplay/chat_manager.py</code> <pre><code>async def open(\n    self, chat_name: str, timeout: int = DEFAULT_WAIT_TIMEOUT, open_via_url: bool = False\n) -&gt; bool:\n    \"\"\"\n    Open a chat by name.\n\n    Args:\n        chat_name: Name of the chat to open\n        timeout: Maximum time to wait in milliseconds\n        open_via_url: If True, forces opening via URL (for phone numbers)\n\n    Returns:\n        True if chat was opened successfully, False otherwise\n    \"\"\"\n    return await self.wa_elements.open(chat_name, timeout, open_via_url=open_via_url)\n</code></pre>"},{"location":"api-reference/#whatsplay.chat_manager.ChatManager.react_to_last_message","title":"<code>react_to_last_message(emoji)</code>  <code>async</code>","text":"<p>React to the last visible message in the current chat.</p> <p>Parameters:</p> Name Type Description Default <code>emoji</code> <code>str</code> <p>The emoji to react with (e.g., \"\ud83d\udc4d\", \"\u2764\ufe0f\")</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if reaction was successful, False otherwise</p> Source code in <code>src/whatsplay/chat_manager.py</code> <pre><code>async def react_to_last_message(self, emoji: str) -&gt; bool:\n    \"\"\"\n    React to the last visible message in the current chat.\n\n    Args:\n        emoji: The emoji to react with (e.g., \"\ud83d\udc4d\", \"\u2764\ufe0f\")\n\n    Returns:\n        True if reaction was successful, False otherwise\n    \"\"\"\n    try:\n        messages = await self.collect_messages()\n        if not messages:\n            await self.client.emit(\"on_warning\", \"No messages found to react to.\")\n            return False\n\n        last_message = messages[-1]\n        await last_message.react(emoji)\n        return True\n    except Exception as e:\n        await self.client.emit(\"on_error\", f\"Error reacting to last message: {e}\")\n        return False\n</code></pre>"},{"location":"api-reference/#whatsplay.chat_manager.ChatManager.search_conversations","title":"<code>search_conversations(query, close=True)</code>  <code>async</code>","text":"<p>Search for conversations by term.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Search term</p> required <code>close</code> <code>bool</code> <p>If True, closes the search after completion</p> <code>True</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of matching conversations</p> Source code in <code>src/whatsplay/chat_manager.py</code> <pre><code>async def search_conversations(\n    self, query: str, close: bool = True\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Search for conversations by term.\n\n    Args:\n        query: Search term\n        close: If True, closes the search after completion\n\n    Returns:\n        List of matching conversations\n    \"\"\"\n    if not await self.client.wait_until_logged_in():\n        return []\n    try:\n        return await self.wa_elements.search_chats(query, close)\n    except Exception as e:\n        await self.client.emit(\"on_error\", f\"Search error: {e}\")\n        return []\n</code></pre>"},{"location":"api-reference/#whatsplay.chat_manager.ChatManager.send_file","title":"<code>send_file(chat_name, path)</code>  <code>async</code>","text":"<p>Send a file attachment to a chat.</p> <p>Parameters:</p> Name Type Description Default <code>chat_name</code> <code>str</code> <p>Name of the chat to send the file to</p> required <code>path</code> <code>str</code> <p>Absolute path to the file to send</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if file was sent successfully, False otherwise</p> Source code in <code>src/whatsplay/chat_manager.py</code> <pre><code>async def send_file(self, chat_name: str, path: str) -&gt; bool:\n    \"\"\"\n    Send a file attachment to a chat.\n\n    Args:\n        chat_name: Name of the chat to send the file to\n        path: Absolute path to the file to send\n\n    Returns:\n        True if file was sent successfully, False otherwise\n    \"\"\"\n    try:\n        if not os.path.isfile(path):\n            msg = f\"File does not exist: {path}\"\n            await self.client.emit(\"on_error\", msg)\n            return False\n\n        if not await self.client.wait_until_logged_in():\n            msg = \"Could not log in\"\n            await self.client.emit(\"on_error\", msg)\n            return False\n\n        if not await self.open(chat_name):\n            msg = f\"Could not open chat: {chat_name}\"\n            await self.client.emit(\"on_error\", msg)\n            return False\n\n        await self._page.wait_for_selector(loc.CHAT_INPUT_BOX, timeout=DEFAULT_WAIT_TIMEOUT)\n\n        attach_btn = await self._page.wait_for_selector(\n            loc.ATTACH_BUTTON, timeout=5000\n        )\n        await attach_btn.click()\n\n        input_files = await self._page.query_selector_all(loc.FILE_INPUT)\n        if not input_files:\n            msg = \"Could not find input[type='file']\"\n            await self.client.emit(\"on_error\", msg)\n            return False\n\n        await input_files[0].set_input_files(path)\n        await asyncio.sleep(1)\n\n        send_btn = await self._page.wait_for_selector(\n            loc.SEND_BUTTON, timeout=DEFAULT_WAIT_TIMEOUT\n        )\n        await send_btn.click()\n\n        return True\n\n    except Exception as e:\n        msg = f\"Unexpected error in send_file: {str(e)}\"\n        await self.client.emit(\"on_error\", msg)\n        await self._page.screenshot(path=\"send_file_error.png\")\n        return False\n    finally:\n        await self.close()\n</code></pre>"},{"location":"api-reference/#whatsplay.chat_manager.ChatManager.send_message","title":"<code>send_message(chat_query, message, open_via_url=False)</code>  <code>async</code>","text":"<p>Send a text message to a chat.</p> <p>Parameters:</p> Name Type Description Default <code>chat_query</code> <code>str</code> <p>Name or identifier of the chat</p> required <code>message</code> <code>str</code> <p>Text message to send</p> required <code>open_via_url</code> <code>bool</code> <p>If True, opens the chat via URL before sending</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if message was sent successfully, False otherwise</p> Source code in <code>src/whatsplay/chat_manager.py</code> <pre><code>async def send_message(\n    self, chat_query: str, message: str, open_via_url: bool = False\n) -&gt; bool:\n    \"\"\"\n    Send a text message to a chat.\n\n    Args:\n        chat_query: Name or identifier of the chat\n        message: Text message to send\n        open_via_url: If True, opens the chat via URL before sending\n\n    Returns:\n        True if message was sent successfully, False otherwise\n    \"\"\"\n    print(\"Sending message...\")\n    if not await self.client.wait_until_logged_in():\n        return False\n\n    try:\n        opened = await self.open(chat_query, open_via_url=open_via_url)\n        if not opened:\n            await self.client.emit(\n                \"on_error\", f\"Could not open chat: {chat_query}\"\n            )\n            return False\n        print(f\"\u2713 Chat '{chat_query}' opened, sending message\")\n\n        await self._page.wait_for_selector(loc.CHAT_INPUT_BOX, timeout=DEFAULT_WAIT_TIMEOUT)\n        input_box = await self._page.wait_for_selector(\n            loc.CHAT_INPUT_BOX, timeout=DEFAULT_WAIT_TIMEOUT\n        )\n\n        if not input_box:\n            await self.client.emit(\n                \"on_error\",\n                \"Could not find text input box for sending message\",\n            )\n            return False\n\n        await input_box.click()\n        await input_box.fill(message)\n        await self._page.keyboard.press(\"Enter\")\n\n        # Add a short delay to allow the message to be processed by WhatsApp Web UI\n        await asyncio.sleep(2)\n\n        return True\n\n    except Exception as e:\n        await self._page.screenshot(path=\"send_message_error.png\")\n        await self.client.emit(\"on_error\", f\"Error sending message: {e}\")\n        return False\n    finally:\n        await self.close()\n</code></pre>"},{"location":"api-reference/#state-manager","title":"State Manager","text":"<p>Responsible for managing the client's internal state.</p>"},{"location":"api-reference/#whatsplay.state_manager.StateManager","title":"<code>whatsplay.state_manager.StateManager</code>","text":"<p>Manages WhatsApp Web client state transitions and QR code handling.</p> <p>This class monitors the WhatsApp Web state and triggers appropriate actions for each state transition, including QR code display, authentication handling, and unread message detection.</p> <p>Attributes:</p> Name Type Description <code>client</code> <p>Reference to the main WhatsApp client</p> <code>_page</code> <p>Playwright page object for browser interactions</p> <code>wa_elements</code> <p>WhatsApp Web elements helper</p> <code>last_qr_shown</code> <code>Optional[bytes]</code> <p>Binary data of the last displayed QR code</p> <code>qr_server_started</code> <code>bool</code> <p>Flag indicating if QR server is running</p> Source code in <code>src/whatsplay/state_manager.py</code> <pre><code>class StateManager:\n    \"\"\"\n    Manages WhatsApp Web client state transitions and QR code handling.\n\n    This class monitors the WhatsApp Web state and triggers appropriate\n    actions for each state transition, including QR code display,\n    authentication handling, and unread message detection.\n\n    Attributes:\n        client: Reference to the main WhatsApp client\n        _page: Playwright page object for browser interactions\n        wa_elements: WhatsApp Web elements helper\n        last_qr_shown: Binary data of the last displayed QR code\n        qr_server_started: Flag indicating if QR server is running\n    \"\"\"\n\n    def __init__(self, client: \"Client\") -&gt; None:\n        \"\"\"\n        Initialize StateManager with client reference.\n\n        Args:\n            client: The main WhatsApp client instance\n        \"\"\"\n        self.client = client\n        self._page = client._page\n        self.wa_elements = client.wa_elements\n        self.last_qr_shown: Optional[bytes] = None\n        self.qr_server_started: bool = False\n\n    async def _get_state(self) -&gt; Optional[State]:\n        \"\"\"\n        Get the current state of WhatsApp Web.\n\n        Returns:\n            Current State enum value or None if state cannot be determined\n        \"\"\"\n        return await self.wa_elements.get_state()\n\n    async def _handle_qr_logic(self, qr_binary: bytes) -&gt; bool:\n        \"\"\"\n        Handle the logic for showing and updating the QR code.\n\n        This method manages the QR code server lifecycle and updates\n        the displayed QR code when it changes.\n\n        Args:\n            qr_binary: Binary data of the QR code image\n\n        Returns:\n            True if QR code was updated or shown, False otherwise\n        \"\"\"\n        if not qr_binary or qr_binary == self.last_qr_shown:\n            return False\n\n        if not self.qr_server_started:\n            show_qr_window(qr_binary)\n            self.qr_server_started = True\n        else:\n            update_qr_code(qr_binary)\n\n        self.last_qr_shown = qr_binary\n        return True\n\n    async def _handle_state_change(\n        self, curr_state: State, prev_state: Optional[State]\n    ) -&gt; None:\n        \"\"\"\n        Handle state transitions.\n\n        This method is called when the WhatsApp Web state changes and\n        triggers appropriate actions for each state.\n\n        Args:\n            curr_state: Current state\n            prev_state: Previous state (may be None on first detection)\n        \"\"\"\n        if curr_state == State.AUTH:\n            await self._handle_auth_state()\n\n        elif curr_state == State.QR_AUTH:\n            await self._handle_qr_auth_state_change()\n\n        elif curr_state == State.LOADING:\n            await self._handle_loading_state()\n\n        elif curr_state == State.LOGGED_IN:\n            await self._handle_logged_in_state_change()\n\n    async def _handle_auth_state(self) -&gt; None:\n        \"\"\"Handle the authentication state.\"\"\"\n        await self.client.emit(\"on_auth\")\n\n    async def _handle_qr_auth_state_change(self) -&gt; None:\n        \"\"\"Handle QR authentication state transition.\"\"\"\n        try:\n            qr_code_canvas = await self._page.wait_for_selector(\n                loc.QR_CODE, timeout=QR_CODE_TIMEOUT\n            )\n            qr_binary = await self._extract_image_from_canvas(qr_code_canvas)\n\n            if await self._handle_qr_logic(qr_binary):\n                await self.client.emit(\"on_qr\", qr_binary)\n\n        except PlaywrightTimeoutError:\n            await self.client.emit(\n                \"on_warning\", \"Timeout waiting for QR code\"\n            )\n        except Exception as e:\n            await self.client.emit(\"on_error\", f\"Error processing QR code: {e}\")\n\n    async def _handle_loading_state(self) -&gt; None:\n        \"\"\"Handle the loading state.\"\"\"\n        loading_chats = (\n            await self.wa_elements.wait_for_selector(loc.LOADING_CHATS) is not None\n        )\n        await self.client.emit(\"on_loading\", loading_chats)\n\n    async def _handle_logged_in_state_change(self) -&gt; None:\n        \"\"\"Handle logged-in state transition.\"\"\"\n        if self.qr_server_started:\n            close_qr_window()\n            self.qr_server_started = False\n\n        await self.client.emit(\"on_logged_in\")\n        await self._handle_logged_in_state()\n\n    async def _handle_same_state(self, state: State) -&gt; None:\n        \"\"\"\n        Handle logic when the state hasn't changed.\n\n        This method is called on each tick when the state remains the same,\n        allowing for periodic actions like QR code refresh or unread message checks.\n\n        Args:\n            state: Current state\n        \"\"\"\n        if state == State.QR_AUTH:\n            await self._handle_qr_auth_state()\n        elif state == State.LOGGED_IN:\n            await self._handle_logged_in_state()\n\n    async def _handle_qr_auth_state(self) -&gt; None:\n        \"\"\"\n        Handle QR authentication state (periodic check).\n\n        Checks if the QR code has changed and updates the display if necessary.\n        \"\"\"\n        try:\n            qr_code_canvas = await self._page.query_selector(loc.QR_CODE)\n            if not qr_code_canvas:\n                return\n\n            curr_qr_binary = await self._extract_image_from_canvas(qr_code_canvas)\n\n            if await self._handle_qr_logic(curr_qr_binary):\n                await self.client.emit(\"on_qr_change\", curr_qr_binary)\n\n        except Exception as e:\n            await self.client.emit(\"on_warning\", f\"Error updating QR code: {e}\")\n\n    async def _handle_logged_in_state(self) -&gt; None:\n        \"\"\"\n        Handle logged-in state (periodic check).\n\n        Checks for continue buttons and unread chats when in logged-in state.\n        \"\"\"\n        try:\n            # Check for continue button (privacy policy updates, etc.)\n            continue_button = await self._page.query_selector(\n                \"button:has(div:has-text('Continue'))\"\n            )\n            if continue_button:\n                await continue_button.click()\n                await asyncio.sleep(DEFAULT_SLEEP_AFTER_CONTINUE)\n                return\n\n            # Check for unread chats\n            unread_chats = await self.client.chat_manager._check_unread_chats()\n            if unread_chats:\n                await self.client.emit(\"on_unread_chat\", unread_chats)\n\n        except Exception as e:\n            await self.client.emit(\"on_error\", f\"Error in logged-in state: {e}\")\n\n    async def _extract_image_from_canvas(\n        self, canvas_element: Optional[ElementHandle]\n    ) -&gt; Optional[bytes]:\n        \"\"\"\n        Extract image data from a canvas element.\n\n        Args:\n            canvas_element: Canvas element containing the image\n\n        Returns:\n            Binary image data or None if extraction fails\n        \"\"\"\n        if not canvas_element:\n            return None\n\n        try:\n            return await canvas_element.screenshot()\n        except Exception as e:\n            await self.client.emit(\"on_error\", f\"Error extracting QR image: {e}\")\n            return None\n</code></pre>"},{"location":"api-reference/#whatsplay.state_manager.StateManager.__init__","title":"<code>__init__(client)</code>","text":"<p>Initialize StateManager with client reference.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>The main WhatsApp client instance</p> required Source code in <code>src/whatsplay/state_manager.py</code> <pre><code>def __init__(self, client: \"Client\") -&gt; None:\n    \"\"\"\n    Initialize StateManager with client reference.\n\n    Args:\n        client: The main WhatsApp client instance\n    \"\"\"\n    self.client = client\n    self._page = client._page\n    self.wa_elements = client.wa_elements\n    self.last_qr_shown: Optional[bytes] = None\n    self.qr_server_started: bool = False\n</code></pre>"},{"location":"api-reference/#authentication","title":"Authentication","text":"<p>Authentication handlers are used to manage the WhatsApp session.</p>"},{"location":"api-reference/#local-profile-auth","title":"Local Profile Auth","text":"<p>The recommended handler for saving your session locally to avoid repeated QR scans.</p>"},{"location":"api-reference/#whatsplay.auth.local_profile_auth.LocalProfileAuth","title":"<code>whatsplay.auth.local_profile_auth.LocalProfileAuth</code>","text":"<p>               Bases: <code>AuthBase</code></p> <p>Authentication using a local browser profile</p> Source code in <code>src/whatsplay/auth/local_profile_auth.py</code> <pre><code>class LocalProfileAuth(AuthBase):\n    \"\"\"Authentication using a local browser profile\"\"\"\n\n    def __init__(self, data_dir: str, profile: str = \"Default\"):\n        super().__init__()\n        self.data_dir = os.path.abspath(data_dir)\n        self.profile = profile\n        self.profile_path = os.path.join(self.data_dir, self.profile)\n        os.makedirs(self.profile_path, exist_ok=True)\n\n    def get_browser_args(self) -&gt; Dict[str, Any]:\n        \"\"\"Get browser launch arguments for profile\"\"\"\n        return {\n            \"headless\": False,  # Profile persistence doesn't work well in headless mode\n            \"args\": [\n                \"--no-sandbox\",\n                \"--disable-setuid-sandbox\",\n                \"--disable-dev-shm-usage\",\n            ],\n        }\n\n    async def setup_context(self, context: BrowserContext) -&gt; None:\n        \"\"\"Configure browser context with profile settings\"\"\"\n        await context.storage_state(path=os.path.join(self.profile_path, \"state.json\"))\n\n    async def save_session(self) -&gt; bool:\n        \"\"\"Save browser session state\"\"\"\n        try:\n            os.makedirs(self.profile_path, exist_ok=True)\n            return True\n        except Exception as e:\n            print(f\"Error saving session: {e}\")\n            return False\n\n    async def load_session(self) -&gt; bool:\n        \"\"\"Check if profile exists and has state\"\"\"\n        state_file = os.path.join(self.profile_path, \"state.json\")\n        return os.path.exists(self.profile_path) and os.path.exists(state_file)\n</code></pre>"},{"location":"api-reference/#whatsplay.auth.local_profile_auth.LocalProfileAuth.get_browser_args","title":"<code>get_browser_args()</code>","text":"<p>Get browser launch arguments for profile</p> Source code in <code>src/whatsplay/auth/local_profile_auth.py</code> <pre><code>def get_browser_args(self) -&gt; Dict[str, Any]:\n    \"\"\"Get browser launch arguments for profile\"\"\"\n    return {\n        \"headless\": False,  # Profile persistence doesn't work well in headless mode\n        \"args\": [\n            \"--no-sandbox\",\n            \"--disable-setuid-sandbox\",\n            \"--disable-dev-shm-usage\",\n        ],\n    }\n</code></pre>"},{"location":"api-reference/#whatsplay.auth.local_profile_auth.LocalProfileAuth.load_session","title":"<code>load_session()</code>  <code>async</code>","text":"<p>Check if profile exists and has state</p> Source code in <code>src/whatsplay/auth/local_profile_auth.py</code> <pre><code>async def load_session(self) -&gt; bool:\n    \"\"\"Check if profile exists and has state\"\"\"\n    state_file = os.path.join(self.profile_path, \"state.json\")\n    return os.path.exists(self.profile_path) and os.path.exists(state_file)\n</code></pre>"},{"location":"api-reference/#whatsplay.auth.local_profile_auth.LocalProfileAuth.save_session","title":"<code>save_session()</code>  <code>async</code>","text":"<p>Save browser session state</p> Source code in <code>src/whatsplay/auth/local_profile_auth.py</code> <pre><code>async def save_session(self) -&gt; bool:\n    \"\"\"Save browser session state\"\"\"\n    try:\n        os.makedirs(self.profile_path, exist_ok=True)\n        return True\n    except Exception as e:\n        print(f\"Error saving session: {e}\")\n        return False\n</code></pre>"},{"location":"api-reference/#whatsplay.auth.local_profile_auth.LocalProfileAuth.setup_context","title":"<code>setup_context(context)</code>  <code>async</code>","text":"<p>Configure browser context with profile settings</p> Source code in <code>src/whatsplay/auth/local_profile_auth.py</code> <pre><code>async def setup_context(self, context: BrowserContext) -&gt; None:\n    \"\"\"Configure browser context with profile settings\"\"\"\n    await context.storage_state(path=os.path.join(self.profile_path, \"state.json\"))\n</code></pre>"},{"location":"api-reference/#no-auth","title":"No Auth","text":"<p>A handler that does not save any session data, requiring a new login on every run.</p>"},{"location":"api-reference/#whatsplay.auth.no_auth.NoAuth","title":"<code>whatsplay.auth.no_auth.NoAuth</code>","text":"<p>               Bases: <code>AuthBase</code></p> <p>Authentication strategy that doesn't persist any data</p> Source code in <code>src/whatsplay/auth/no_auth.py</code> <pre><code>class NoAuth(AuthBase):\n    \"\"\"Authentication strategy that doesn't persist any data\"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n    def get_browser_args(self) -&gt; Dict[str, Any]:\n        \"\"\"Get browser launch arguments\"\"\"\n        return {\"headless\": False}\n\n    async def setup_context(self, context: BrowserContext) -&gt; None:\n        \"\"\"No special configuration needed\"\"\"\n        pass\n\n    async def save_session(self) -&gt; bool:\n        \"\"\"No session to save\"\"\"\n        return False\n\n    async def load_session(self) -&gt; bool:\n        \"\"\"No session to load\"\"\"\n        return False\n</code></pre>"},{"location":"api-reference/#whatsplay.auth.no_auth.NoAuth.get_browser_args","title":"<code>get_browser_args()</code>","text":"<p>Get browser launch arguments</p> Source code in <code>src/whatsplay/auth/no_auth.py</code> <pre><code>def get_browser_args(self) -&gt; Dict[str, Any]:\n    \"\"\"Get browser launch arguments\"\"\"\n    return {\"headless\": False}\n</code></pre>"},{"location":"api-reference/#whatsplay.auth.no_auth.NoAuth.load_session","title":"<code>load_session()</code>  <code>async</code>","text":"<p>No session to load</p> Source code in <code>src/whatsplay/auth/no_auth.py</code> <pre><code>async def load_session(self) -&gt; bool:\n    \"\"\"No session to load\"\"\"\n    return False\n</code></pre>"},{"location":"api-reference/#whatsplay.auth.no_auth.NoAuth.save_session","title":"<code>save_session()</code>  <code>async</code>","text":"<p>No session to save</p> Source code in <code>src/whatsplay/auth/no_auth.py</code> <pre><code>async def save_session(self) -&gt; bool:\n    \"\"\"No session to save\"\"\"\n    return False\n</code></pre>"},{"location":"api-reference/#whatsplay.auth.no_auth.NoAuth.setup_context","title":"<code>setup_context(context)</code>  <code>async</code>","text":"<p>No special configuration needed</p> Source code in <code>src/whatsplay/auth/no_auth.py</code> <pre><code>async def setup_context(self, context: BrowserContext) -&gt; None:\n    \"\"\"No special configuration needed\"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/#filters","title":"Filters","text":"<p>The <code>filters</code> module provides classes and instances to filter events.</p>"},{"location":"api-reference/#predefined-message-filters","title":"Predefined Message Filters","text":"<p>A collection of ready-to-use filters for the <code>on_message</code> event.</p>"},{"location":"api-reference/#whatsplay.filters.message_filter","title":"<code>whatsplay.filters.message_filter</code>","text":"<p>Message filtering utilities for WhatsApp messages</p>"},{"location":"api-reference/#whatsplay.filters.message_filter.MessageFilter","title":"<code>MessageFilter</code>","text":"<p>Helper class for filtering WhatsApp messages</p> Source code in <code>src/whatsplay/filters/message_filter.py</code> <pre><code>class MessageFilter:\n    \"\"\"Helper class for filtering WhatsApp messages\"\"\"\n\n    @classmethod\n    def filter_search_result(cls, text: str) -&gt; list[str]:\n        \"\"\"Filtra y formatea un resultado de b\u00fasqueda\n\n        Returns:\n            List[str]: (texto_formateado)\n        \"\"\"\n        text = text.strip()\n\n        # Formatear el resultado\n        lines = text.split(\"\\n\")\n        if len(lines) &gt;= 2:\n            name = lines[0].strip()\n            date = lines[1].strip()\n            message = \" \".join(lines[2:]).strip() if len(lines) &gt; 2 else \"\"\n\n            # No mostrar si el mensaje est\u00e1 vac\u00edo o muy corto\n            if not message or len(message) &lt; 2:\n                return text\n\n            # No mostrar si el mensaje solo contiene n\u00fameros o caracteres especiales\n            if all(c.isdigit() or c in \".,-_+=/\\\\\" for c in message.replace(\" \", \"\")):\n                return text\n\n            text_formatted = {\"name\": name, \"date\": date, \"message\": message}\n            return text_formatted\n\n        return text\n</code></pre>"},{"location":"api-reference/#whatsplay.filters.message_filter.MessageFilter.filter_search_result","title":"<code>filter_search_result(text)</code>  <code>classmethod</code>","text":"<p>Filtra y formatea un resultado de b\u00fasqueda</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List[str]: (texto_formateado)</p> Source code in <code>src/whatsplay/filters/message_filter.py</code> <pre><code>@classmethod\ndef filter_search_result(cls, text: str) -&gt; list[str]:\n    \"\"\"Filtra y formatea un resultado de b\u00fasqueda\n\n    Returns:\n        List[str]: (texto_formateado)\n    \"\"\"\n    text = text.strip()\n\n    # Formatear el resultado\n    lines = text.split(\"\\n\")\n    if len(lines) &gt;= 2:\n        name = lines[0].strip()\n        date = lines[1].strip()\n        message = \" \".join(lines[2:]).strip() if len(lines) &gt; 2 else \"\"\n\n        # No mostrar si el mensaje est\u00e1 vac\u00edo o muy corto\n        if not message or len(message) &lt; 2:\n            return text\n\n        # No mostrar si el mensaje solo contiene n\u00fameros o caracteres especiales\n        if all(c.isdigit() or c in \".,-_+=/\\\\\" for c in message.replace(\" \", \"\")):\n            return text\n\n        text_formatted = {\"name\": name, \"date\": date, \"message\": message}\n        return text_formatted\n\n    return text\n</code></pre>"},{"location":"api-reference/#custom-filter-base-class","title":"Custom Filter Base Class","text":"<p>Inherit from this class to create your own powerful, reusable filters.</p>"},{"location":"api-reference/#whatsplay.filters.filters.CustomFilter","title":"<code>whatsplay.filters.filters.CustomFilter</code>","text":"<p>               Bases: <code>Filter</code></p> <p>A filter that uses a custom function to test values.</p> Source code in <code>src/whatsplay/filters/filters.py</code> <pre><code>class CustomFilter(Filter):\n    \"\"\"\n    A filter that uses a custom function to test values.\n    \"\"\"\n\n    def __init__(self, func: Callable[[Any], bool]):\n        self.func = func\n\n    def test(self, value: Any) -&gt; bool:\n        return self.func(value)\n</code></pre>"},{"location":"getting-started/","title":"Getting Started with WhatsPlay","text":"<p>This guide will walk you through installing WhatsPlay and writing your first script to send a WhatsApp message.</p>"},{"location":"getting-started/#1-installation","title":"1. Installation","text":"<p>WhatsPlay requires Python 3.8 or newer. You can install it directly from PyPI. We also recommend installing Playwright's browser dependencies.</p> <p>First, install the library:</p> <pre><code>pip install whatsplay\n</code></pre> <p>Next, install the necessary browser binaries for Playwright (this will download a browser like Chromium):</p> <pre><code>playwright install\n</code></pre>"},{"location":"getting-started/#2-your-first-script-sending-a-message","title":"2. Your First Script: Sending a Message","text":"<p>Let's create a simple script that logs into WhatsApp and sends a message.</p> <p>Create a new Python file, for example <code>send_hello.py</code>, and add the following code.</p> <pre><code>import asyncio\nfrom whatsplay import Client\nfrom whatsplay.auth import LocalProfileAuth\n\nasync def main():\n    \"\"\"\n    Main function to initialize the client, send a message, and stop.\n    \"\"\"\n\n    # --- Step 1: Set up Authentication ---\n    # This tells WhatsPlay to save session data in a folder named \"whatsapp_session\".\n    # This way, you only need to scan the QR code once.\n    auth = LocalProfileAuth(user_data_dir=\"./whatsapp_session\")\n\n    # --- Step 2: Initialize the Client ---\n    # We run in headless=False for the first time to make it easy to scan the QR code.\n    # You can set it to headless=True later for background execution.\n    client = Client(auth=auth, headless=False)\n\n    # --- Step 3: Define Event Handlers ---\n    # `on_start` is triggered once the client is logged in and ready.\n    @client.event(\"on_start\")\n    async def on_start():\n        print(\"Client is ready! Preparing to send a message...\")\n\n        # Define your recipient and message\n        # IMPORTANT: Replace with a real phone number or contact name.\n        # For phone numbers, use the format with country code but no '+' or '00'.\n        recipient = \"1234567890\" \n        message = \"This is my first message from WhatsPlay! \ud83c\udf89\"\n\n        # Send the message\n        success = await client.send_message(recipient, message)\n\n        if success:\n            print(f\"Message sent successfully to {recipient}!\")\n        else:\n            print(f\"Oops! Failed to send message to {recipient}.\")\n\n        # Stop the client after the job is done\n        print(\"Work complete. Shutting down...\")\n        await client.stop()\n\n    # `on_qr` is triggered if a QR scan is needed.\n    @client.event(\"on_qr\")\n    async def on_qr(qr):\n        print(\"Login required. A browser window should open for you to scan the QR code.\")\n\n    # `on_auth` is triggered if authentication is required\n    @client.event(\"on_auth\")\n    async def on_auth():\n        print(\"Authentication is required.\")\n\n    # `on_error` catches potential errors during execution\n    @client.event(\"on_error\")\n    async def on_error(error):\n        print(f\"An error occurred: {error}\")\n        await client.stop()\n\n    # --- Step 4: Start the Client ---\n    # This call starts the browser and begins the login process.\n    await client.start()\n    print(\"Script has finished executing.\")\n\n# --- Run the main function ---\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"getting-started/#how-to-run-it","title":"How to Run It","text":"<ol> <li>Save the code: Save the script as <code>send_hello.py</code>.</li> <li>Modify the recipient: Change <code>\"1234567890\"</code> to a real phone number or a contact name saved in your WhatsApp.</li> <li>Execute from your terminal: <pre><code>python send_hello.py\n</code></pre></li> <li>First-time Login: A browser window will open. Scan the WhatsApp Web QR code with your phone.</li> <li>Subsequent Runs: The script will reuse the session and should log in automatically. The message will be sent, and the script will exit.</li> </ol>"},{"location":"guides/group-management/","title":"Guide: Group Management","text":"<p>WhatsPlay provides robust functionality for managing WhatsApp groups, allowing you to create new groups and manage their members programmatically.</p>"},{"location":"guides/group-management/#creating-a-new-group","title":"Creating a New Group","text":"<p>You can create a new WhatsApp group by using the <code>client.new_group()</code> method. This method requires a group name and a list of contact names or phone numbers for the initial members.</p> <p>Important: The contacts in the <code>members</code> list must already be in your WhatsApp contacts or be valid phone numbers (including country code, without '+' or '00').</p> <pre><code>import asyncio\nfrom whatsplay import Client\nfrom whatsplay.auth import LocalProfileAuth\n\nasync def create_my_group():\n    auth = LocalProfileAuth(user_data_dir=\"./whatsapp_session\")\n    client = Client(auth=auth, headless=True) # Set headless=False if you want to see the browser\n\n    @client.event(\"on_start\")\n    async def on_start():\n        print(\"Client ready. Attempting to create a new group...\")\n\n        group_name = \"My Awesome WhatsPlay Group\"\n        # Use existing contact names or phone numbers\n        initial_members = [\"Contact Name 1\", \"5491123456789\"] # Example: \"54911...\" for Argentina mobile\n\n        success = await client.new_group(group_name, initial_members)\n\n        if success:\n            print(f\"Group '{group_name}' created successfully with initial members.\")\n        else:\n            print(f\"Failed to create group '{group_name}'.\")\n\n        await client.stop()\n\n    @client.event(\"on_qr\")\n    async def on_qr(qr):\n        print(\"Please scan the QR code to log in.\")\n\n    await client.start()\n\nif __name__ == \"__main__\":\n    asyncio.run(create_my_group())\n</code></pre>"},{"location":"guides/group-management/#adding-members-to-an-existing-group","title":"Adding Members to an Existing Group","text":"<p>To add more members to an already existing group, use the <code>client.add_members_to_group()</code> method. You need to provide the name of the group and a list of members to add.</p> <pre><code>import asyncio\nfrom whatsplay import Client\nfrom whatsplay.auth import LocalProfileAuth\n\nasync def add_members_to_existing_group():\n    auth = LocalProfileAuth(user_data_dir=\"./whatsapp_session\")\n    client = Client(auth=auth, headless=True)\n\n    @client.event(\"on_start\")\n    async def on_start():\n        print(\"Client ready. Attempting to add members to a group...\")\n\n        group_name = \"My Awesome WhatsPlay Group\" # Must be an existing group\n        new_members = [\"New Contact Name 1\", \"5491198765432\"]\n\n        success = await client.add_members_to_group(group_name, new_members)\n\n        if success:\n            print(f\"Members added successfully to '{group_name}'.\")\n        else:\n            print(f\"Failed to add members to '{group_name}'.\")\n\n        await client.stop()\n\n    @client.event(\"on_qr\")\n    async def on_qr(qr):\n        print(\"Please scan the QR code to log in.\")\n\n    await client.start()\n\nif __name__ == \"__main__\":\n    asyncio.run(add_members_to_existing_group())\n</code></pre>"},{"location":"guides/group-management/#removing-members-from-a-group","title":"Removing Members from a Group","text":"<p>You can remove members from a group using the <code>client.del_members_from_group()</code> method. Provide the group name and a list of members to remove.</p> <pre><code>import asyncio\nfrom whatsplay import Client\nfrom whatsplay.auth import LocalProfileAuth\n\nasync def remove_members_from_group():\n    auth = LocalProfileAuth(user_data_dir=\"./whatsapp_session\")\n    client = Client(auth=auth, headless=True)\n\n    @client.event(\"on_start\")\n    async def on_start():\n        print(\"Client ready. Attempting to remove members from a group...\")\n\n        group_name = \"My Awesome WhatsPlay Group\" # Must be an existing group\n        members_to_remove = [\"Contact Name To Remove\", \"5491112345678\"]\n\n        success = await client.del_members_from_group(group_name, members_to_remove)\n\n        if success:\n            print(f\"Members removed successfully from '{group_name}'.\")\n        else:\n            print(f\"Failed to remove members from '{group_name}'.\")\n\n        await client.stop()\n\n    @client.event(\"on_qr\")\n    async def on_qr(qr):\n        print(\"Please scan the QR code to log in.\")\n\n    await client.start()\n\nif __name__ == \"__main__\":\n    asyncio.run(remove_members_from_group())\n</code></pre>"},{"location":"guides/group-management/#further-group-management-features-under-consideration","title":"Further Group Management Features (Under Consideration)","text":"<p>While WhatsPlay provides core group management capabilities, future enhancements could include:</p> <ul> <li>Promote/Demote Group Administrators: Functionality to change a member's administrative status.</li> <li>Update Group Information: Methods to change the group's subject (name) or description after creation.</li> <li>Retrieve Detailed Participant List: A way to get a full list of group members along with their roles (admin/participant).</li> </ul> <p>Stay tuned for updates as WhatsPlay evolves!</p>"},{"location":"guides/handling-messages/","title":"Guide: Handling Incoming Messages","text":"<p>WhatsPlay's event-driven architecture makes it easy to react to incoming messages in real-time. This guide will show you how to set up handlers for messages and how to filter them.</p>"},{"location":"guides/handling-messages/#the-on_message-event","title":"The <code>on_message</code> Event","text":"<p>The core of handling incoming messages is subscribing to the <code>on_message</code> event. Your handler function will receive a <code>message</code> object which contains all the details about the incoming message.</p> <pre><code>import asyncio\nfrom whatsplay import Client\nfrom whatsplay.auth import LocalProfileAuth\nfrom whatsplay.event import Message\n\nasync def basic_message_handler():\n    auth = LocalProfileAuth(user_data_dir=\"./whatsapp_session\")\n    client = Client(auth=auth, headless=True)\n\n    @client.event(\"on_start\")\n    async def on_start():\n        print(\"Client ready. Waiting for messages...\")\n\n    # This handler will be called for every incoming message\n    @client.event(\"on_message\")\n    async def handle_any_message(message: Message):\n        print(f\"Received a message!\")\n        print(f\"  From: {message.sender.name or message.sender.id}\")\n        print(f\"  Chat: {message.chat.name or message.chat.id}\")\n        print(f\"  Text: {message.text}\")\n\n        # Example: Reply to the sender\n        if message.text and \"hello\" in message.text.lower():\n            await message.reply(\"Hello there! How can I help you?\")\n\n    @client.event(\"on_qr\")\n    async def on_qr(qr):\n        print(\"Please scan the QR code to log in.\")\n\n    # Keep the client running indefinitely to listen for messages\n    await client.start()\n    # You might want to add client.run_forever() here if your script is only for listening\n    # However, for simple examples, client.start() is sufficient if you don't call client.stop() immediately.\n\nif __name__ == \"__main__\":\n    asyncio.run(basic_message_handler())\n</code></pre>"},{"location":"guides/handling-messages/#filtering-messages","title":"Filtering Messages","text":"<p>WhatsPlay provides powerful filtering capabilities to help you process only the messages you care about. You can pass a filter object to the <code>on_message</code> event decorator.</p>"},{"location":"guides/handling-messages/#using-predefined-filters","title":"Using Predefined Filters","text":"<p>The <code>whatsplay.filters</code> module offers several ready-to-use filters.</p> <pre><code>import asyncio\nfrom whatsplay import Client\nfrom whatsplay.auth import LocalProfileAuth\nfrom whatsplay.event import Message\nfrom whatsplay.filters import message_filter\n\nasync def filtered_message_handler():\n    auth = LocalProfileAuth(user_data_dir=\"./whatsapp_session\")\n    client = Client(auth=auth, headless=True)\n\n    @client.event(\"on_start\")\n    async def on_start():\n        print(\"Client ready. Waiting for filtered messages...\")\n\n    # Only handle messages that are text (not media, etc.)\n    @client.event(\"on_message\", message_filter.text)\n    async def handle_text_message(message: Message):\n        print(f\"Received a TEXT message from {message.sender.name or message.sender.id}: {message.text}\")\n\n    # Only handle messages from a specific sender (by name or ID)\n    @client.event(\"on_message\", message_filter.sender(\"John Doe\"))\n    async def handle_message_from_john(message: Message):\n        print(f\"Received a message from John Doe: {message.text}\")\n\n    # Only handle messages matching a regular expression\n    @client.event(\"on_message\", message_filter.regex(r\"^\\/command\"))\n    async def handle_command_message(message: Message):\n        print(f\"Received a command: {message.text}\")\n        await message.reply(\"Command received!\")\n\n    @client.event(\"on_qr\")\n    async def on_qr(qr):\n        print(\"Please scan the QR code to log in.\")\n\n    await client.start()\n\nif __name__ == \"__main__\":\n    asyncio.run(filtered_message_handler())\n</code></pre>"},{"location":"guides/handling-messages/#creating-custom-filters","title":"Creating Custom Filters","text":"<p>You can also define your own custom filter functions or classes for more complex logic. A filter function should accept a <code>message</code> object and return <code>True</code> if the message should be processed by the handler, <code>False</code> otherwise.</p> <pre><code>import asyncio\nfrom whatsplay import Client\nfrom whatsplay.auth import LocalProfileAuth\nfrom whatsplay.event import Message\nfrom whatsplay.filters import CustomFilter\n\n# Custom filter function\ndef my_custom_filter(message: Message) -&gt; bool:\n    # Only process messages that contain \"important\" and are from a specific chat type\n    return message.text and \"important\" in message.text.lower() and message.chat.is_group\n\n# Or a CustomFilter class (more powerful for reusable, stateful filters)\nclass MyChatIdFilter(CustomFilter):\n    def __init__(self, chat_id_to_match: str):\n        self.chat_id_to_match = chat_id_to_match\n\n    def __call__(self, message: Message) -&gt; bool:\n        return message.chat.id == self.chat_id_to_match\n\n\nasync def custom_filtered_message_handler():\n    auth = LocalProfileAuth(user_data_dir=\"./whatsapp_session\")\n    client = Client(auth=auth, headless=True)\n\n    @client.event(\"on_start\")\n    async def on_start():\n        print(\"Client ready. Waiting for custom filtered messages...\")\n\n    # Using the custom filter function\n    @client.event(\"on_message\", my_custom_filter)\n    async def handle_custom_filtered_message(message: Message):\n        print(f\"Received an 'important' message in a group from {message.sender.name}: {message.text}\")\n\n    # Using the custom filter class\n    target_chat_id = \"1234567890@g.us\" # Replace with a real chat ID\n    @client.event(\"on_message\", MyChatIdFilter(target_chat_id))\n    async def handle_specific_chat_message(message: Message):\n        print(f\"Received message in specific chat ({target_chat_id}): {message.text}\")\n\n    @client.event(\"on_qr\")\n    async def on_qr(qr):\n        print(\"Please scan the QR code to log in.\")\n\n    await client.start()\n\nif __name__ == \"__main__\":\n    asyncio.run(custom_filtered_message_handler())\n</code></pre>"},{"location":"guides/handling-messages/#accessing-message-data","title":"Accessing Message Data","text":"<p>The <code>Message</code> object passed to your handler contains a wealth of information about the incoming message. Some key attributes include:</p> <ul> <li><code>message.id</code>: Unique ID of the message.</li> <li><code>message.text</code>: The text content of the message (if any).</li> <li><code>message.sender</code>: A <code>User</code> object representing the sender (with <code>name</code> and <code>id</code>).</li> <li><code>message.chat</code>: A <code>Chat</code> object representing the conversation (with <code>name</code>, <code>id</code>, <code>is_group</code>, <code>is_user</code>).</li> <li><code>message.timestamp</code>: When the message was sent.</li> <li><code>message.is_media</code>: Boolean, <code>True</code> if the message contains media (image, video, etc.).</li> <li><code>message.media_type</code>: Type of media, e.g., 'image', 'video', 'document'.</li> <li><code>message.download_media()</code>: An awaitable method to download attached media.</li> <li><code>message.reply(text)</code>: An awaitable method to reply directly to this message.</li> </ul> <p>This guide provides the foundation for building interactive and responsive WhatsPlay applications. Combine message handling with filters to create powerful automation scenarios!</p>"},{"location":"guides/sending-media/","title":"Guide: Sending and Receiving Media","text":"<p>WhatsPlay makes it easy to work with media like images, videos, and documents. This guide covers both sending files from your local disk and downloading media from incoming messages.</p>"},{"location":"guides/sending-media/#sending-media","title":"Sending Media","text":"<p>The primary method for sending any kind of file is <code>client.send_file()</code>. You need to provide the recipient (chat name or ID) and the local path to the file. WhatsPlay will handle the rest.</p> <p>You can also provide an optional <code>caption</code> for the media.</p>"},{"location":"guides/sending-media/#example-sending-an-image-with-a-caption","title":"Example: Sending an Image with a Caption","text":"<p>This script sends a local image file to a specified recipient.</p> <pre><code>import asyncio\nfrom pathlib import Path\nfrom whatsplay import Client\nfrom whatsplay.auth import LocalProfileAuth\n\nasync def send_media_file():\n    auth = LocalProfileAuth(user_data_dir=\"./whatsapp_session\")\n    client = Client(auth=auth, headless=True)\n\n    @client.event(\"on_start\")\n    async def on_start():\n        print(\"Client ready. Sending an image...\")\n\n        recipient = \"PHONE_NUMBER_OR_CONTACT_NAME\"\n\n        # Ensure you have an image at this path\n        # For example: /home/user/pictures/my_image.jpg\n        file_path = Path(\"/path/to/your/image.jpg\")\n        caption = \"Here is a picture from WhatsPlay! \ud83d\uddbc\ufe0f\"\n\n        if not file_path.exists():\n            print(f\"Error: File not found at {file_path}\")\n            await client.stop()\n            return\n\n        success = await client.send_file(recipient, file_path, caption=caption)\n\n        if success:\n            print(f\"Media sent successfully to {recipient}.\")\n        else:\n            print(f\"Failed to send media to {recipient}.\")\n\n        await client.stop()\n\n    @client.event(\"on_qr\")\n    async def on_qr(qr):\n        print(\"Please scan the QR code to log in.\")\n\n    await client.start()\n\nif __name__ == \"__main__\":\n    asyncio.run(send_media_file())\n</code></pre> <p>You can use the same <code>client.send_file()</code> method for any file type, including: *   Images (<code>.jpg</code>, <code>.png</code>, etc.) *   Videos (<code>.mp4</code>, <code>.mov</code>, etc.) *   Documents (<code>.pdf</code>, <code>.docx</code>, <code>.zip</code>, etc.) *   Audio files (<code>.mp3</code>, <code>.ogg</code>, etc.)</p>"},{"location":"guides/sending-media/#downloading-media","title":"Downloading Media","text":"<p>When you receive a message that contains media, the <code>Message</code> object provides a convenient way to download it.</p> <ol> <li>Check if the message contains media using <code>message.is_media</code>.</li> <li>If it does, call the <code>await message.download_media()</code> method.</li> </ol> <p>This method downloads the file to a specified location. If no path is provided, it may use a default directory.</p>"},{"location":"guides/sending-media/#example-auto-downloader-bot","title":"Example: Auto-downloader Bot","text":"<p>This bot automatically downloads any media it receives.</p> <pre><code>import asyncio\nfrom pathlib import Path\nfrom whatsplay import Client\nfrom whatsplay.auth import LocalProfileAuth\nfrom whatsplay.event import Message\n\nasync def media_downloader_bot():\n    # Create a directory to save downloaded files\n    download_dir = Path(\"./media_downloads\")\n    download_dir.mkdir(exist_ok=True)\n\n    print(f\"Will save downloaded media to: {download_dir.resolve()}\")\n\n    auth = LocalProfileAuth(user_data_dir=\"./whatsapp_session\")\n    client = Client(auth=auth, headless=True)\n\n    @client.event(\"on_start\")\n    async def on_start():\n        print(\"Downloader bot started. Waiting for media...\")\n\n    @client.event(\"on_message\")\n    async def handle_message(message: Message):\n        if message.is_media:\n            print(f\"Received media of type '{message.media_type}' from {message.sender.name or message.sender.id}.\")\n\n            # Define a path to save the file\n            # You can customize the filename, here we use the message ID\n            save_path = download_dir / f\"{message.id}-{message.media_filename or 'download'}\"\n\n            print(f\"Downloading to {save_path}...\")\n\n            try:\n                await message.download_media(save_path)\n                print(\"Download successful!\")\n                await message.reply(f\"Thanks! I've saved the file as {save_path.name}.\")\n            except Exception as e:\n                print(f\"Error downloading file: {e}\")\n                await message.reply(\"Sorry, I had an error trying to download your file.\")\n\n    @client.event(\"on_qr\")\n    async def on_qr(qr):\n        print(\"Please scan the QR code to log in.\")\n\n    await client.start()\n\nif __name__ == \"__main__\":\n    asyncio.run(media_downloader_bot())\n</code></pre> <p>This bot will listen for incoming messages, and if one contains media, it will attempt to download it into the <code>media_downloads</code> folder in your project directory.</p>"},{"location":"es/","title":"Bienvenido a WhatsPlay","text":"<p>Este es un placeholder para la traducci\u00f3n al espa\u00f1ol.</p> <p>WhatsPlay is a Python library for automating WhatsApp Web using Playwright. It provides a simple, event-driven interface to interact with chats, send messages, manage groups, and much more.</p> <p>Whether you want to build a bot, automate your daily reports, or scrape chat data, WhatsPlay gives you the tools to do it efficiently.</p>"},{"location":"es/api-reference/","title":"Referencia de API","text":"<p>Este es un placeholder para la traducci\u00f3n al espa\u00f1ol.</p> <p>This page provides an auto-generated API reference for the key components of the WhatsPlay library.</p>"},{"location":"es/getting-started/","title":"Empezando con WhatsPlay","text":"<p>Este es un placeholder para la traducci\u00f3n al espa\u00f1ol.</p> <p>This guide will walk you through installing WhatsPlay and writing your first script to send a WhatsApp message.</p>"},{"location":"es/guides/group-management/","title":"Gu\u00eda: Administraci\u00f3n de Grupos","text":"<p>Este es un placeholder para la traducci\u00f3n al espa\u00f1ol.</p> <p>WhatsPlay provides robust functionality for managing WhatsApp groups, allowing you to create new groups and manage their members programmatically.</p>"},{"location":"es/guides/handling-messages/","title":"Gu\u00eda: Manejo de Mensajes Entrantes","text":"<p>Este es un placeholder para la traducci\u00f3n al espa\u00f1ol.</p> <p>WhatsPlay's event-driven architecture makes it easy to react to incoming messages in real-time. This guide will show you how to set up handlers for messages and how to filter them.</p>"},{"location":"es/guides/sending-media/","title":"Gu\u00eda: Env\u00edo y Recepci\u00f3n de Archivos Multimedia","text":"<p>Este es un placeholder para la traducci\u00f3n al espa\u00f1ol.</p> <p>WhatsPlay makes it easy to work with media like images, videos, and documents. This guide covers both sending files from your local disk and downloading media from incoming messages.</p>"}]}